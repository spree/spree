// @codemirror/state@6.5.2 downloaded from https://ga.jspm.io/npm:@codemirror/state@6.5.2/dist/index.js

import{findClusterBreak as e}from"@marijn/find-cluster-break";class Text{lineAt(e){if(e<0||e>this.length)throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);return this.lineInner(e,false,1,0)}line(e){if(e<1||e>this.lines)throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);return this.lineInner(e,true,1,0)}replace(e,t,n){[e,t]=clip(this,e,t);let i=[];this.decompose(0,e,i,2);n.length&&n.decompose(0,n.length,i,3);this.decompose(t,this.length,i,1);return TextNode.from(i,this.length-(t-e)+n.length)}append(e){return this.replace(this.length,this.length,e)}slice(e,t=this.length){[e,t]=clip(this,e,t);let n=[];this.decompose(e,t,n,0);return TextNode.from(n,t-e)}eq(e){if(e==this)return true;if(e.length!=this.length||e.lines!=this.lines)return false;let t=this.scanIdentical(e,1),n=this.length-this.scanIdentical(e,-1);let i=new RawTextCursor(this),s=new RawTextCursor(e);for(let e=t,r=t;;){i.next(e);s.next(e);e=0;if(i.lineBreak!=s.lineBreak||i.done!=s.done||i.value!=s.value)return false;r+=i.value.length;if(i.done||r>=n)return true}}iter(e=1){return new RawTextCursor(this,e)}iterRange(e,t=this.length){return new PartialTextCursor(this,e,t)}iterLines(e,t){let n;if(e==null)n=this.iter();else{t==null&&(t=this.lines+1);let i=this.line(e).from;n=this.iterRange(i,Math.max(i,t==this.lines+1?this.length:t<=1?0:this.line(t-1).to))}return new LineCursor(n)}toString(){return this.sliceString(0)}toJSON(){let e=[];this.flatten(e);return e}constructor(){}static of(e){if(e.length==0)throw new RangeError("A document must have at least one line");return e.length!=1||e[0]?e.length<=32?new TextLeaf(e):TextNode.from(TextLeaf.split(e,[])):Text.empty}}class TextLeaf extends Text{constructor(e,t=textLength(e)){super();this.text=e;this.length=t}get lines(){return this.text.length}get children(){return null}lineInner(e,t,n,i){for(let s=0;;s++){let r=this.text[s],a=i+r.length;if((t?n:a)>=e)return new Line(i,a,n,r);i=a+1;n++}}decompose(e,t,n,i){let s=e<=0&&t>=this.length?this:new TextLeaf(sliceText(this.text,e,t),Math.min(t,this.length)-Math.max(0,e));if(i&1){let e=n.pop();let t=appendText(s.text,e.text.slice(),0,s.length);if(t.length<=32)n.push(new TextLeaf(t,e.length+s.length));else{let e=t.length>>1;n.push(new TextLeaf(t.slice(0,e)),new TextLeaf(t.slice(e)))}}else n.push(s)}replace(e,t,n){if(!(n instanceof TextLeaf))return super.replace(e,t,n);[e,t]=clip(this,e,t);let i=appendText(this.text,appendText(n.text,sliceText(this.text,0,e)),t);let s=this.length+n.length-(t-e);return i.length<=32?new TextLeaf(i,s):TextNode.from(TextLeaf.split(i,[]),s)}sliceString(e,t=this.length,n="\n"){[e,t]=clip(this,e,t);let i="";for(let s=0,r=0;s<=t&&r<this.text.length;r++){let a=this.text[r],o=s+a.length;s>e&&r&&(i+=n);e<o&&t>s&&(i+=a.slice(Math.max(0,e-s),t-s));s=o+1}return i}flatten(e){for(let t of this.text)e.push(t)}scanIdentical(){return 0}static split(e,t){let n=[],i=-1;for(let s of e){n.push(s);i+=s.length+1;if(n.length==32){t.push(new TextLeaf(n,i));n=[];i=-1}}i>-1&&t.push(new TextLeaf(n,i));return t}}class TextNode extends Text{constructor(e,t){super();this.children=e;this.length=t;this.lines=0;for(let t of e)this.lines+=t.lines}lineInner(e,t,n,i){for(let s=0;;s++){let r=this.children[s],a=i+r.length,o=n+r.lines-1;if((t?o:a)>=e)return r.lineInner(e,t,n,i);i=a+1;n=o+1}}decompose(e,t,n,i){for(let s=0,r=0;r<=t&&s<this.children.length;s++){let a=this.children[s],o=r+a.length;if(e<=o&&t>=r){let s=i&((r<=e?1:0)|(o>=t?2:0));r>=e&&o<=t&&!s?n.push(a):a.decompose(e-r,t-r,n,s)}r=o+1}}replace(e,t,n){[e,t]=clip(this,e,t);if(n.lines<this.lines)for(let i=0,s=0;i<this.children.length;i++){let r=this.children[i],a=s+r.length;if(e>=s&&t<=a){let o=r.replace(e-s,t-s,n);let l=this.lines-r.lines+o.lines;if(o.lines<l>>4&&o.lines>l>>6){let s=this.children.slice();s[i]=o;return new TextNode(s,this.length-(t-e)+n.length)}return super.replace(s,a,o)}s=a+1}return super.replace(e,t,n)}sliceString(e,t=this.length,n="\n"){[e,t]=clip(this,e,t);let i="";for(let s=0,r=0;s<this.children.length&&r<=t;s++){let a=this.children[s],o=r+a.length;r>e&&s&&(i+=n);e<o&&t>r&&(i+=a.sliceString(e-r,t-r,n));r=o+1}return i}flatten(e){for(let t of this.children)t.flatten(e)}scanIdentical(e,t){if(!(e instanceof TextNode))return 0;let n=0;let[i,s,r,a]=t>0?[0,0,this.children.length,e.children.length]:[this.children.length-1,e.children.length-1,-1,-1];for(;;i+=t,s+=t){if(i==r||s==a)return n;let o=this.children[i],l=e.children[s];if(o!=l)return n+o.scanIdentical(l,t);n+=o.length+1}}static from(e,t=e.reduce(((e,t)=>e+t.length+1),-1)){let n=0;for(let t of e)n+=t.lines;if(n<32){let n=[];for(let t of e)t.flatten(n);return new TextLeaf(n,t)}let i=Math.max(32,n>>5),s=i<<1,r=i>>1;let a=[],o=0,l=-1,h=[];function add(e){let t;if(e.lines>s&&e instanceof TextNode)for(let t of e.children)add(t);else if(e.lines>r&&(o>r||!o)){flush();a.push(e)}else if(e instanceof TextLeaf&&o&&(t=h[h.length-1])instanceof TextLeaf&&e.lines+t.lines<=32){o+=e.lines;l+=e.length+1;h[h.length-1]=new TextLeaf(t.text.concat(e.text),t.length+1+e.length)}else{o+e.lines>i&&flush();o+=e.lines;l+=e.length+1;h.push(e)}}function flush(){if(o!=0){a.push(h.length==1?h[0]:TextNode.from(h,l));l=-1;o=h.length=0}}for(let t of e)add(t);flush();return a.length==1?a[0]:new TextNode(a,t)}}Text.empty=new TextLeaf([""],0);function textLength(e){let t=-1;for(let n of e)t+=n.length+1;return t}function appendText(e,t,n=0,i=1e9){for(let s=0,r=0,a=true;r<e.length&&s<=i;r++){let o=e[r],l=s+o.length;if(l>=n){l>i&&(o=o.slice(0,i-s));s<n&&(o=o.slice(n-s));if(a){t[t.length-1]+=o;a=false}else t.push(o)}s=l+1}return t}function sliceText(e,t,n){return appendText(e,[""],t,n)}class RawTextCursor{constructor(e,t=1){this.dir=t;this.done=false;this.lineBreak=false;this.value="";this.nodes=[e];this.offsets=[t>0?1:(e instanceof TextLeaf?e.text.length:e.children.length)<<1]}nextInner(e,t){this.done=this.lineBreak=false;for(;;){let n=this.nodes.length-1;let i=this.nodes[n],s=this.offsets[n],r=s>>1;let a=i instanceof TextLeaf?i.text.length:i.children.length;if(r==(t>0?a:0)){if(n==0){this.done=true;this.value="";return this}t>0&&this.offsets[n-1]++;this.nodes.pop();this.offsets.pop()}else if((s&1)==(t>0?0:1)){this.offsets[n]+=t;if(e==0){this.lineBreak=true;this.value="\n";return this}e--}else if(i instanceof TextLeaf){let s=i.text[r+(t<0?-1:0)];this.offsets[n]+=t;if(s.length>Math.max(0,e)){this.value=e==0?s:t>0?s.slice(e):s.slice(0,s.length-e);return this}e-=s.length}else{let s=i.children[r+(t<0?-1:0)];if(e>s.length){e-=s.length;this.offsets[n]+=t}else{t<0&&this.offsets[n]--;this.nodes.push(s);this.offsets.push(t>0?1:(s instanceof TextLeaf?s.text.length:s.children.length)<<1)}}}}next(e=0){if(e<0){this.nextInner(-e,-this.dir);e=this.value.length}return this.nextInner(e,this.dir)}}class PartialTextCursor{constructor(e,t,n){this.value="";this.done=false;this.cursor=new RawTextCursor(e,t>n?-1:1);this.pos=t>n?e.length:0;this.from=Math.min(t,n);this.to=Math.max(t,n)}nextInner(e,t){if(t<0?this.pos<=this.from:this.pos>=this.to){this.value="";this.done=true;return this}e+=Math.max(0,t<0?this.pos-this.to:this.from-this.pos);let n=t<0?this.pos-this.from:this.to-this.pos;e>n&&(e=n);n-=e;let{value:i}=this.cursor.next(e);this.pos+=(i.length+e)*t;this.value=i.length<=n?i:t<0?i.slice(i.length-n):i.slice(0,n);this.done=!this.value;return this}next(e=0){e<0?e=Math.max(e,this.from-this.pos):e>0&&(e=Math.min(e,this.to-this.pos));return this.nextInner(e,this.cursor.dir)}get lineBreak(){return this.cursor.lineBreak&&this.value!=""}}class LineCursor{constructor(e){this.inner=e;this.afterBreak=true;this.value="";this.done=false}next(e=0){let{done:t,lineBreak:n,value:i}=this.inner.next(e);if(t&&this.afterBreak){this.value="";this.afterBreak=false}else if(t){this.done=true;this.value=""}else if(n)if(this.afterBreak)this.value="";else{this.afterBreak=true;this.next()}else{this.value=i;this.afterBreak=false}return this}get lineBreak(){return false}}if(typeof Symbol!="undefined"){Text.prototype[Symbol.iterator]=function(){return this.iter()};RawTextCursor.prototype[Symbol.iterator]=PartialTextCursor.prototype[Symbol.iterator]=LineCursor.prototype[Symbol.iterator]=function(){return this}}class Line{constructor(e,t,n,i){this.from=e;this.to=t;this.number=n;this.text=i}get length(){return this.to-this.from}}function clip(e,t,n){t=Math.max(0,Math.min(e.length,t));return[t,Math.max(t,Math.min(e.length,n))]}function findClusterBreak(t,n,i=true,s=true){return e(t,n,i,s)}function surrogateLow(e){return e>=56320&&e<57344}function surrogateHigh(e){return e>=55296&&e<56320}function codePointAt(e,t){let n=e.charCodeAt(t);if(!surrogateHigh(n)||t+1==e.length)return n;let i=e.charCodeAt(t+1);return surrogateLow(i)?i-56320+(n-55296<<10)+65536:n}function fromCodePoint(e){if(e<=65535)return String.fromCharCode(e);e-=65536;return String.fromCharCode(55296+(e>>10),56320+(e&1023))}function codePointSize(e){return e<65536?1:2}const t=/\r\n?|\n/;var n=function(e){e[e.Simple=0]="Simple";e[e.TrackDel=1]="TrackDel";e[e.TrackBefore=2]="TrackBefore";e[e.TrackAfter=3]="TrackAfter";return e}(n||(n={}));class ChangeDesc{constructor(e){this.sections=e}get length(){let e=0;for(let t=0;t<this.sections.length;t+=2)e+=this.sections[t];return e}get newLength(){let e=0;for(let t=0;t<this.sections.length;t+=2){let n=this.sections[t+1];e+=n<0?this.sections[t]:n}return e}get empty(){return this.sections.length==0||this.sections.length==2&&this.sections[1]<0}iterGaps(e){for(let t=0,n=0,i=0;t<this.sections.length;){let s=this.sections[t++],r=this.sections[t++];if(r<0){e(n,i,s);i+=s}else i+=r;n+=s}}iterChangedRanges(e,t=false){iterChanges(this,e,t)}get invertedDesc(){let e=[];for(let t=0;t<this.sections.length;){let n=this.sections[t++],i=this.sections[t++];i<0?e.push(n,i):e.push(i,n)}return new ChangeDesc(e)}composeDesc(e){return this.empty?e:e.empty?this:composeSets(this,e)}mapDesc(e,t=false){return e.empty?this:mapSet(this,e,t)}mapPos(e,t=-1,i=n.Simple){let s=0,r=0;for(let a=0;a<this.sections.length;){let o=this.sections[a++],l=this.sections[a++],h=s+o;if(l<0){if(h>e)return r+(e-s);r+=o}else{if(i!=n.Simple&&h>=e&&(i==n.TrackDel&&s<e&&h>e||i==n.TrackBefore&&s<e||i==n.TrackAfter&&h>e))return null;if(h>e||h==e&&t<0&&!o)return e==s||t<0?r:r+l;r+=l}s=h}if(e>s)throw new RangeError(`Position ${e} is out of range for changeset of length ${s}`);return r}touchesRange(e,t=e){for(let n=0,i=0;n<this.sections.length&&i<=t;){let s=this.sections[n++],r=this.sections[n++],a=i+s;if(r>=0&&i<=t&&a>=e)return!(i<e&&a>t)||"cover";i=a}return false}toString(){let e="";for(let t=0;t<this.sections.length;){let n=this.sections[t++],i=this.sections[t++];e+=(e?" ":"")+n+(i>=0?":"+i:"")}return e}toJSON(){return this.sections}static fromJSON(e){if(!Array.isArray(e)||e.length%2||e.some((e=>typeof e!="number")))throw new RangeError("Invalid JSON representation of ChangeDesc");return new ChangeDesc(e)}static create(e){return new ChangeDesc(e)}}class ChangeSet extends ChangeDesc{constructor(e,t){super(e);this.inserted=t}apply(e){if(this.length!=e.length)throw new RangeError("Applying change set to a document with the wrong length");iterChanges(this,((t,n,i,s,r)=>e=e.replace(i,i+(n-t),r)),false);return e}mapDesc(e,t=false){return mapSet(this,e,t,true)}invert(e){let t=this.sections.slice(),n=[];for(let i=0,s=0;i<t.length;i+=2){let r=t[i],a=t[i+1];if(a>=0){t[i]=a;t[i+1]=r;let o=i>>1;while(n.length<o)n.push(Text.empty);n.push(r?e.slice(s,s+r):Text.empty)}s+=r}return new ChangeSet(t,n)}compose(e){return this.empty?e:e.empty?this:composeSets(this,e,true)}map(e,t=false){return e.empty?this:mapSet(this,e,t,true)}iterChanges(e,t=false){iterChanges(this,e,t)}get desc(){return ChangeDesc.create(this.sections)}filter(e){let t=[],n=[],i=[];let s=new SectionIter(this);e:for(let r=0,a=0;;){let o=r==e.length?1e9:e[r++];while(a<o||a==o&&s.len==0){if(s.done)break e;let e=Math.min(s.len,o-a);addSection(i,e,-1);let r=s.ins==-1?-1:s.off==0?s.ins:0;addSection(t,e,r);r>0&&addInsert(n,t,s.text);s.forward(e);a+=e}let l=e[r++];while(a<l){if(s.done)break e;let e=Math.min(s.len,l-a);addSection(t,e,-1);addSection(i,e,s.ins==-1?-1:s.off==0?s.ins:0);s.forward(e);a+=e}}return{changes:new ChangeSet(t,n),filtered:ChangeDesc.create(i)}}toJSON(){let e=[];for(let t=0;t<this.sections.length;t+=2){let n=this.sections[t],i=this.sections[t+1];i<0?e.push(n):i==0?e.push([n]):e.push([n].concat(this.inserted[t>>1].toJSON()))}return e}static of(e,n,i){let s=[],r=[],a=0;let o=null;function flush(e=false){if(!e&&!s.length)return;a<n&&addSection(s,n-a,-1);let t=new ChangeSet(s,r);o=o?o.compose(t.map(o)):t;s=[];r=[];a=0}function process(e){if(Array.isArray(e))for(let t of e)process(t);else if(e instanceof ChangeSet){if(e.length!=n)throw new RangeError(`Mismatched change set length (got ${e.length}, expected ${n})`);flush();o=o?o.compose(e.map(o)):e}else{let{from:o,to:l=o,insert:h}=e;if(o>l||o<0||l>n)throw new RangeError(`Invalid change range ${o} to ${l} (in doc of length ${n})`);let c=h?typeof h=="string"?Text.of(h.split(i||t)):h:Text.empty;let f=c.length;if(o==l&&f==0)return;o<a&&flush();o>a&&addSection(s,o-a,-1);addSection(s,l-o,f);addInsert(r,s,c);a=l}}process(e);flush(!o);return o}static empty(e){return new ChangeSet(e?[e,-1]:[],[])}static fromJSON(e){if(!Array.isArray(e))throw new RangeError("Invalid JSON representation of ChangeSet");let t=[],n=[];for(let i=0;i<e.length;i++){let s=e[i];if(typeof s=="number")t.push(s,-1);else{if(!Array.isArray(s)||typeof s[0]!="number"||s.some(((e,t)=>t&&typeof e!="string")))throw new RangeError("Invalid JSON representation of ChangeSet");if(s.length==1)t.push(s[0],0);else{while(n.length<i)n.push(Text.empty);n[i]=Text.of(s.slice(1));t.push(s[0],n[i].length)}}}return new ChangeSet(t,n)}static createSet(e,t){return new ChangeSet(e,t)}}function addSection(e,t,n,i=false){if(t==0&&n<=0)return;let s=e.length-2;if(s>=0&&n<=0&&n==e[s+1])e[s]+=t;else if(s>=0&&t==0&&e[s]==0)e[s+1]+=n;else if(i){e[s]+=t;e[s+1]+=n}else e.push(t,n)}function addInsert(e,t,n){if(n.length==0)return;let i=t.length-2>>1;if(i<e.length)e[e.length-1]=e[e.length-1].append(n);else{while(e.length<i)e.push(Text.empty);e.push(n)}}function iterChanges(e,t,n){let i=e.inserted;for(let s=0,r=0,a=0;a<e.sections.length;){let o=e.sections[a++],l=e.sections[a++];if(l<0){s+=o;r+=o}else{let h=s,c=r,f=Text.empty;for(;;){h+=o;c+=l;l&&i&&(f=f.append(i[a-2>>1]));if(n||a==e.sections.length||e.sections[a+1]<0)break;o=e.sections[a++];l=e.sections[a++]}t(s,h,r,c,f);s=h;r=c}}}function mapSet(e,t,n,i=false){let s=[],r=i?[]:null;let a=new SectionIter(e),o=new SectionIter(t);for(let e=-1;;){if(a.done&&o.len||o.done&&a.len)throw new Error("Mismatched change set lengths");if(a.ins==-1&&o.ins==-1){let e=Math.min(a.len,o.len);addSection(s,e,-1);a.forward(e);o.forward(e)}else if(o.ins>=0&&(a.ins<0||e==a.i||a.off==0&&(o.len<a.len||o.len==a.len&&!n))){let t=o.len;addSection(s,o.ins,-1);while(t){let n=Math.min(a.len,t);if(a.ins>=0&&e<a.i&&a.len<=n){addSection(s,0,a.ins);r&&addInsert(r,s,a.text);e=a.i}a.forward(n);t-=n}o.next()}else{if(!(a.ins>=0)){if(a.done&&o.done)return r?ChangeSet.createSet(s,r):ChangeDesc.create(s);throw new Error("Mismatched change set lengths")}{let t=0,n=a.len;while(n)if(o.ins==-1){let e=Math.min(n,o.len);t+=e;n-=e;o.forward(e)}else{if(!(o.ins==0&&o.len<n))break;n-=o.len;o.next()}addSection(s,t,e<a.i?a.ins:0);r&&e<a.i&&addInsert(r,s,a.text);e=a.i;a.forward(a.len-n)}}}}function composeSets(e,t,n=false){let i=[];let s=n?[]:null;let r=new SectionIter(e),a=new SectionIter(t);for(let e=false;;){if(r.done&&a.done)return s?ChangeSet.createSet(i,s):ChangeDesc.create(i);if(r.ins==0){addSection(i,r.len,0,e);r.next()}else if(a.len!=0||a.done){if(r.done||a.done)throw new Error("Mismatched change set lengths");{let t=Math.min(r.len2,a.len),n=i.length;if(r.ins==-1){let n=a.ins==-1?-1:a.off?0:a.ins;addSection(i,t,n,e);s&&n&&addInsert(s,i,a.text)}else if(a.ins==-1){addSection(i,r.off?0:r.len,t,e);s&&addInsert(s,i,r.textBit(t))}else{addSection(i,r.off?0:r.len,a.off?0:a.ins,e);s&&!a.off&&addInsert(s,i,a.text)}e=(r.ins>t||a.ins>=0&&a.len>t)&&(e||i.length>n);r.forward2(t);a.forward(t)}}else{addSection(i,0,a.ins,e);s&&addInsert(s,i,a.text);a.next()}}}class SectionIter{constructor(e){this.set=e;this.i=0;this.next()}next(){let{sections:e}=this.set;if(this.i<e.length){this.len=e[this.i++];this.ins=e[this.i++]}else{this.len=0;this.ins=-2}this.off=0}get done(){return this.ins==-2}get len2(){return this.ins<0?this.len:this.ins}get text(){let{inserted:e}=this.set,t=this.i-2>>1;return t>=e.length?Text.empty:e[t]}textBit(e){let{inserted:t}=this.set,n=this.i-2>>1;return n>=t.length&&!e?Text.empty:t[n].slice(this.off,e==null?void 0:this.off+e)}forward(e){if(e==this.len)this.next();else{this.len-=e;this.off+=e}}forward2(e){if(this.ins==-1)this.forward(e);else if(e==this.ins)this.next();else{this.ins-=e;this.off+=e}}}class SelectionRange{constructor(e,t,n){this.from=e;this.to=t;this.flags=n}get anchor(){return this.flags&32?this.to:this.from}get head(){return this.flags&32?this.from:this.to}get empty(){return this.from==this.to}get assoc(){return this.flags&8?-1:this.flags&16?1:0}get bidiLevel(){let e=this.flags&7;return e==7?null:e}get goalColumn(){let e=this.flags>>6;return e==16777215?void 0:e}map(e,t=-1){let n,i;if(this.empty)n=i=e.mapPos(this.from,t);else{n=e.mapPos(this.from,1);i=e.mapPos(this.to,-1)}return n==this.from&&i==this.to?this:new SelectionRange(n,i,this.flags)}extend(e,t=e){if(e<=this.anchor&&t>=this.anchor)return EditorSelection.range(e,t);let n=Math.abs(e-this.anchor)>Math.abs(t-this.anchor)?e:t;return EditorSelection.range(this.anchor,n)}eq(e,t=false){return this.anchor==e.anchor&&this.head==e.head&&(!t||!this.empty||this.assoc==e.assoc)}toJSON(){return{anchor:this.anchor,head:this.head}}static fromJSON(e){if(!e||typeof e.anchor!="number"||typeof e.head!="number")throw new RangeError("Invalid JSON representation for SelectionRange");return EditorSelection.range(e.anchor,e.head)}static create(e,t,n){return new SelectionRange(e,t,n)}}class EditorSelection{constructor(e,t){this.ranges=e;this.mainIndex=t}map(e,t=-1){return e.empty?this:EditorSelection.create(this.ranges.map((n=>n.map(e,t))),this.mainIndex)}eq(e,t=false){if(this.ranges.length!=e.ranges.length||this.mainIndex!=e.mainIndex)return false;for(let n=0;n<this.ranges.length;n++)if(!this.ranges[n].eq(e.ranges[n],t))return false;return true}get main(){return this.ranges[this.mainIndex]}asSingle(){return this.ranges.length==1?this:new EditorSelection([this.main],0)}addRange(e,t=true){return EditorSelection.create([e].concat(this.ranges),t?0:this.mainIndex+1)}replaceRange(e,t=this.mainIndex){let n=this.ranges.slice();n[t]=e;return EditorSelection.create(n,this.mainIndex)}toJSON(){return{ranges:this.ranges.map((e=>e.toJSON())),main:this.mainIndex}}static fromJSON(e){if(!e||!Array.isArray(e.ranges)||typeof e.main!="number"||e.main>=e.ranges.length)throw new RangeError("Invalid JSON representation for EditorSelection");return new EditorSelection(e.ranges.map((e=>SelectionRange.fromJSON(e))),e.main)}static single(e,t=e){return new EditorSelection([EditorSelection.range(e,t)],0)}static create(e,t=0){if(e.length==0)throw new RangeError("A selection needs at least one range");for(let n=0,i=0;i<e.length;i++){let s=e[i];if(s.empty?s.from<=n:s.from<n)return EditorSelection.normalized(e.slice(),t);n=s.to}return new EditorSelection(e,t)}static cursor(e,t=0,n,i){return SelectionRange.create(e,e,(t==0?0:t<0?8:16)|(n==null?7:Math.min(6,n))|(i!==null&&i!==void 0?i:16777215)<<6)}static range(e,t,n,i){let s=(n!==null&&n!==void 0?n:16777215)<<6|(i==null?7:Math.min(6,i));return t<e?SelectionRange.create(t,e,48|s):SelectionRange.create(e,t,(t>e?8:0)|s)}static normalized(e,t=0){let n=e[t];e.sort(((e,t)=>e.from-t.from));t=e.indexOf(n);for(let n=1;n<e.length;n++){let i=e[n],s=e[n-1];if(i.empty?i.from<=s.to:i.from<s.to){let r=s.from,a=Math.max(i.to,s.to);n<=t&&t--;e.splice(--n,2,i.anchor>i.head?EditorSelection.range(a,r):EditorSelection.range(r,a))}}return new EditorSelection(e,t)}}function checkSelection(e,t){for(let n of e.ranges)if(n.to>t)throw new RangeError("Selection points outside of document")}let i=0;class Facet{constructor(e,t,n,s,r){this.combine=e;this.compareInput=t;this.compare=n;this.isStatic=s;this.id=i++;this.default=e([]);this.extensions=typeof r=="function"?r(this):r}get reader(){return this}static define(e={}){return new Facet(e.combine||(e=>e),e.compareInput||((e,t)=>e===t),e.compare||(e.combine?(e,t)=>e===t:sameArray),!!e.static,e.enables)}of(e){return new FacetProvider([],this,0,e)}compute(e,t){if(this.isStatic)throw new Error("Can't compute a static facet");return new FacetProvider(e,this,1,t)}computeN(e,t){if(this.isStatic)throw new Error("Can't compute a static facet");return new FacetProvider(e,this,2,t)}from(e,t){t||(t=e=>e);return this.compute([e],(n=>t(n.field(e))))}}function sameArray(e,t){return e==t||e.length==t.length&&e.every(((e,n)=>e===t[n]))}class FacetProvider{constructor(e,t,n,s){this.dependencies=e;this.facet=t;this.type=n;this.value=s;this.id=i++}dynamicSlot(e){var t;let n=this.value;let i=this.facet.compareInput;let s=this.id,r=e[s]>>1,a=this.type==2;let o=false,l=false,h=[];for(let n of this.dependencies)n=="doc"?o=true:n=="selection"?l=true:(((t=e[n.id])!==null&&t!==void 0?t:1)&1)==0&&h.push(e[n.id]);return{create(e){e.values[r]=n(e);return 1},update(e,t){if(o&&t.docChanged||l&&(t.docChanged||t.selection)||ensureAll(e,h)){let t=n(e);if(a?!compareArray(t,e.values[r],i):!i(t,e.values[r])){e.values[r]=t;return 1}}return 0},reconfigure:(e,t)=>{let o,l=t.config.address[s];if(l!=null){let s=getAddr(t,l);if(this.dependencies.every((n=>n instanceof Facet?t.facet(n)===e.facet(n):!(n instanceof StateField)||t.field(n,false)==e.field(n,false)))||(a?compareArray(o=n(e),s,i):i(o=n(e),s))){e.values[r]=s;return 0}}else o=n(e);e.values[r]=o;return 1}}}}function compareArray(e,t,n){if(e.length!=t.length)return false;for(let i=0;i<e.length;i++)if(!n(e[i],t[i]))return false;return true}function ensureAll(e,t){let n=false;for(let i of t)ensureAddr(e,i)&1&&(n=true);return n}function dynamicFacetSlot(e,t,n){let i=n.map((t=>e[t.id]));let s=n.map((e=>e.type));let r=i.filter((e=>!(e&1)));let a=e[t.id]>>1;function get(e){let n=[];for(let t=0;t<i.length;t++){let r=getAddr(e,i[t]);if(s[t]==2)for(let e of r)n.push(e);else n.push(r)}return t.combine(n)}return{create(e){for(let t of i)ensureAddr(e,t);e.values[a]=get(e);return 1},update(e,n){if(!ensureAll(e,r))return 0;let i=get(e);if(t.compare(i,e.values[a]))return 0;e.values[a]=i;return 1},reconfigure(e,s){let r=ensureAll(e,i);let o=s.config.facets[t.id],l=s.facet(t);if(o&&!r&&sameArray(n,o)){e.values[a]=l;return 0}let h=get(e);if(t.compare(h,l)){e.values[a]=l;return 0}e.values[a]=h;return 1}}}const s=Facet.define({static:true});class StateField{constructor(e,t,n,i,s){this.id=e;this.createF=t;this.updateF=n;this.compareF=i;this.spec=s;this.provides=void 0}static define(e){let t=new StateField(i++,e.create,e.update,e.compare||((e,t)=>e===t),e);e.provide&&(t.provides=e.provide(t));return t}create(e){let t=e.facet(s).find((e=>e.field==this));return((t===null||t===void 0?void 0:t.create)||this.createF)(e)}slot(e){let t=e[this.id]>>1;return{create:e=>{e.values[t]=this.create(e);return 1},update:(e,n)=>{let i=e.values[t];let s=this.updateF(i,n);if(this.compareF(i,s))return 0;e.values[t]=s;return 1},reconfigure:(e,n)=>{let i,r=e.facet(s),a=n.facet(s);if((i=r.find((e=>e.field==this)))&&i!=a.find((e=>e.field==this))){e.values[t]=i.create(e);return 1}if(n.config.address[this.id]!=null){e.values[t]=n.field(this);return 0}e.values[t]=this.create(e);return 1}}}init(e){return[this,s.of({field:this,create:e})]}get extension(){return this}}const r={lowest:4,low:3,default:2,high:1,highest:0};function prec(e){return t=>new PrecExtension(t,e)}const a={highest:prec(r.highest),high:prec(r.high),default:prec(r.default),low:prec(r.low),lowest:prec(r.lowest)};class PrecExtension{constructor(e,t){this.inner=e;this.prec=t}}class Compartment{of(e){return new CompartmentInstance(this,e)}reconfigure(e){return Compartment.reconfigure.of({compartment:this,extension:e})}get(e){return e.config.compartments.get(this)}}class CompartmentInstance{constructor(e,t){this.compartment=e;this.inner=t}}class Configuration{constructor(e,t,n,i,s,r){this.base=e;this.compartments=t;this.dynamicSlots=n;this.address=i;this.staticValues=s;this.facets=r;this.statusTemplate=[];while(this.statusTemplate.length<n.length)this.statusTemplate.push(0)}staticFacet(e){let t=this.address[e.id];return t==null?e.default:this.staticValues[t>>1]}static resolve(e,t,n){let i=[];let s=Object.create(null);let r=new Map;for(let n of flatten(e,t,r))n instanceof StateField?i.push(n):(s[n.facet.id]||(s[n.facet.id]=[])).push(n);let a=Object.create(null);let o=[];let l=[];for(let e of i){a[e.id]=l.length<<1;l.push((t=>e.slot(t)))}let h=n===null||n===void 0?void 0:n.config.facets;for(let e in s){let t=s[e],i=t[0].facet;let r=h&&h[e]||[];if(t.every((e=>e.type==0))){a[i.id]=o.length<<1|1;if(sameArray(r,t))o.push(n.facet(i));else{let e=i.combine(t.map((e=>e.value)));o.push(n&&i.compare(e,n.facet(i))?n.facet(i):e)}}else{for(let e of t)if(e.type==0){a[e.id]=o.length<<1|1;o.push(e.value)}else{a[e.id]=l.length<<1;l.push((t=>e.dynamicSlot(t)))}a[i.id]=l.length<<1;l.push((e=>dynamicFacetSlot(e,i,t)))}}let c=l.map((e=>e(a)));return new Configuration(e,r,c,a,o,s)}}function flatten(e,t,n){let i=[[],[],[],[],[]];let s=new Map;function inner(e,a){let o=s.get(e);if(o!=null){if(o<=a)return;let t=i[o].indexOf(e);t>-1&&i[o].splice(t,1);e instanceof CompartmentInstance&&n.delete(e.compartment)}s.set(e,a);if(Array.isArray(e))for(let t of e)inner(t,a);else if(e instanceof CompartmentInstance){if(n.has(e.compartment))throw new RangeError("Duplicate use of compartment in extensions");let i=t.get(e.compartment)||e.inner;n.set(e.compartment,i);inner(i,a)}else if(e instanceof PrecExtension)inner(e.inner,e.prec);else if(e instanceof StateField){i[a].push(e);e.provides&&inner(e.provides,a)}else if(e instanceof FacetProvider){i[a].push(e);e.facet.extensions&&inner(e.facet.extensions,r.default)}else{let t=e.extension;if(!t)throw new Error(`Unrecognized extension value in extension set (${e}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);inner(t,a)}}inner(e,r.default);return i.reduce(((e,t)=>e.concat(t)))}function ensureAddr(e,t){if(t&1)return 2;let n=t>>1;let i=e.status[n];if(i==4)throw new Error("Cyclic dependency between fields and/or facets");if(i&2)return i;e.status[n]=4;let s=e.computeSlot(e,e.config.dynamicSlots[n]);return e.status[n]=2|s}function getAddr(e,t){return t&1?e.config.staticValues[t>>1]:e.values[t>>1]}const o=Facet.define();const l=Facet.define({combine:e=>e.some((e=>e)),static:true});const h=Facet.define({combine:e=>e.length?e[0]:void 0,static:true});const c=Facet.define();const f=Facet.define();const u=Facet.define();const d=Facet.define({combine:e=>!!e.length&&e[0]});class Annotation{constructor(e,t){this.type=e;this.value=t}static define(){return new AnnotationType}}class AnnotationType{of(e){return new Annotation(this,e)}}class StateEffectType{constructor(e){this.map=e}of(e){return new StateEffect(this,e)}}class StateEffect{constructor(e,t){this.type=e;this.value=t}map(e){let t=this.type.map(this.value,e);return t===void 0?void 0:t==this.value?this:new StateEffect(this.type,t)}is(e){return this.type==e}static define(e={}){return new StateEffectType(e.map||(e=>e))}static mapEffects(e,t){if(!e.length)return e;let n=[];for(let i of e){let e=i.map(t);e&&n.push(e)}return n}}StateEffect.reconfigure=StateEffect.define();StateEffect.appendConfig=StateEffect.define();class Transaction{constructor(e,t,n,i,s,r){this.startState=e;this.changes=t;this.selection=n;this.effects=i;this.annotations=s;this.scrollIntoView=r;this._doc=null;this._state=null;n&&checkSelection(n,t.newLength);s.some((e=>e.type==Transaction.time))||(this.annotations=s.concat(Transaction.time.of(Date.now())))}static create(e,t,n,i,s,r){return new Transaction(e,t,n,i,s,r)}get newDoc(){return this._doc||(this._doc=this.changes.apply(this.startState.doc))}get newSelection(){return this.selection||this.startState.selection.map(this.changes)}get state(){this._state||this.startState.applyTransaction(this);return this._state}annotation(e){for(let t of this.annotations)if(t.type==e)return t.value}get docChanged(){return!this.changes.empty}get reconfigured(){return this.startState.config!=this.state.config}isUserEvent(e){let t=this.annotation(Transaction.userEvent);return!!(t&&(t==e||t.length>e.length&&t.slice(0,e.length)==e&&t[e.length]=="."))}}Transaction.time=Annotation.define();Transaction.userEvent=Annotation.define();Transaction.addToHistory=Annotation.define();Transaction.remote=Annotation.define();function joinRanges(e,t){let n=[];for(let i=0,s=0;;){let r,a;if(i<e.length&&(s==t.length||t[s]>=e[i])){r=e[i++];a=e[i++]}else{if(!(s<t.length))return n;r=t[s++];a=t[s++]}!n.length||n[n.length-1]<r?n.push(r,a):n[n.length-1]<a&&(n[n.length-1]=a)}}function mergeTransaction(e,t,n){var i;let s,r,a;if(n){s=t.changes;r=ChangeSet.empty(t.changes.length);a=e.changes.compose(t.changes)}else{s=t.changes.map(e.changes);r=e.changes.mapDesc(t.changes,true);a=e.changes.compose(s)}return{changes:a,selection:t.selection?t.selection.map(r):(i=e.selection)===null||i===void 0?void 0:i.map(s),effects:StateEffect.mapEffects(e.effects,s).concat(StateEffect.mapEffects(t.effects,r)),annotations:e.annotations.length?e.annotations.concat(t.annotations):t.annotations,scrollIntoView:e.scrollIntoView||t.scrollIntoView}}function resolveTransactionInner(e,t,n){let i=t.selection,s=asArray(t.annotations);t.userEvent&&(s=s.concat(Transaction.userEvent.of(t.userEvent)));return{changes:t.changes instanceof ChangeSet?t.changes:ChangeSet.of(t.changes||[],n,e.facet(h)),selection:i&&(i instanceof EditorSelection?i:EditorSelection.single(i.anchor,i.head)),effects:asArray(t.effects),annotations:s,scrollIntoView:!!t.scrollIntoView}}function resolveTransaction(e,t,n){let i=resolveTransactionInner(e,t.length?t[0]:{},e.doc.length);t.length&&t[0].filter===false&&(n=false);for(let s=1;s<t.length;s++){t[s].filter===false&&(n=false);let r=!!t[s].sequential;i=mergeTransaction(i,resolveTransactionInner(e,t[s],r?i.changes.newLength:e.doc.length),r)}let s=Transaction.create(e,i.changes,i.selection,i.effects,i.annotations,i.scrollIntoView);return extendTransaction(n?filterTransaction(s):s)}function filterTransaction(e){let t=e.startState;let n=true;for(let i of t.facet(c)){let t=i(e);if(t===false){n=false;break}Array.isArray(t)&&(n=n===true?t:joinRanges(n,t))}if(n!==true){let i,s;if(n===false){s=e.changes.invertedDesc;i=ChangeSet.empty(t.doc.length)}else{let t=e.changes.filter(n);i=t.changes;s=t.filtered.mapDesc(t.changes).invertedDesc}e=Transaction.create(t,i,e.selection&&e.selection.map(s),StateEffect.mapEffects(e.effects,s),e.annotations,e.scrollIntoView)}let i=t.facet(f);for(let n=i.length-1;n>=0;n--){let s=i[n](e);e=s instanceof Transaction?s:Array.isArray(s)&&s.length==1&&s[0]instanceof Transaction?s[0]:resolveTransaction(t,asArray(s),false)}return e}function extendTransaction(e){let t=e.startState,n=t.facet(u),i=e;for(let s=n.length-1;s>=0;s--){let r=n[s](e);r&&Object.keys(r).length&&(i=mergeTransaction(i,resolveTransactionInner(t,r,e.changes.newLength),true))}return i==e?e:Transaction.create(t,e.changes,e.selection,i.effects,i.annotations,i.scrollIntoView)}const g=[];function asArray(e){return e==null?g:Array.isArray(e)?e:[e]}var p=function(e){e[e.Word=0]="Word";e[e.Space=1]="Space";e[e.Other=2]="Other";return e}(p||(p={}));const m=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;let S;try{S=new RegExp("[\\p{Alphabetic}\\p{Number}_]","u")}catch(e){}function hasWordChar(e){if(S)return S.test(e);for(let t=0;t<e.length;t++){let n=e[t];if(/\w/.test(n)||n>""&&(n.toUpperCase()!=n.toLowerCase()||m.test(n)))return true}return false}function makeCategorizer(e){return t=>{if(!/\S/.test(t))return p.Space;if(hasWordChar(t))return p.Word;for(let n=0;n<e.length;n++)if(t.indexOf(e[n])>-1)return p.Word;return p.Other}}class EditorState{constructor(e,t,n,i,s,r){this.config=e;this.doc=t;this.selection=n;this.values=i;this.status=e.statusTemplate.slice();this.computeSlot=s;r&&(r._state=this);for(let e=0;e<this.config.dynamicSlots.length;e++)ensureAddr(this,e<<1);this.computeSlot=null}field(e,t=true){let n=this.config.address[e.id];if(n!=null){ensureAddr(this,n);return getAddr(this,n)}if(t)throw new RangeError("Field is not present in this state")}update(...e){return resolveTransaction(this,e,true)}applyTransaction(e){let t=this.config,{base:n,compartments:i}=t;for(let s of e.effects)if(s.is(Compartment.reconfigure)){if(t){i=new Map;t.compartments.forEach(((e,t)=>i.set(t,e)));t=null}i.set(s.value.compartment,s.value.extension)}else if(s.is(StateEffect.reconfigure)){t=null;n=s.value}else if(s.is(StateEffect.appendConfig)){t=null;n=asArray(n).concat(s.value)}let s;if(t)s=e.startState.values.slice();else{t=Configuration.resolve(n,i,this);let e=new EditorState(t,this.doc,this.selection,t.dynamicSlots.map((()=>null)),((e,t)=>t.reconfigure(e,this)),null);s=e.values}let r=e.startState.facet(l)?e.newSelection:e.newSelection.asSingle();new EditorState(t,e.newDoc,r,s,((t,n)=>n.update(t,e)),e)}replaceSelection(e){typeof e=="string"&&(e=this.toText(e));return this.changeByRange((t=>({changes:{from:t.from,to:t.to,insert:e},range:EditorSelection.cursor(t.from+e.length)})))}changeByRange(e){let t=this.selection;let n=e(t.ranges[0]);let i=this.changes(n.changes),s=[n.range];let r=asArray(n.effects);for(let n=1;n<t.ranges.length;n++){let a=e(t.ranges[n]);let o=this.changes(a.changes),l=o.map(i);for(let e=0;e<n;e++)s[e]=s[e].map(l);let h=i.mapDesc(o,true);s.push(a.range.map(h));i=i.compose(l);r=StateEffect.mapEffects(r,l).concat(StateEffect.mapEffects(asArray(a.effects),h))}return{changes:i,selection:EditorSelection.create(s,t.mainIndex),effects:r}}changes(e=[]){return e instanceof ChangeSet?e:ChangeSet.of(e,this.doc.length,this.facet(EditorState.lineSeparator))}toText(e){return Text.of(e.split(this.facet(EditorState.lineSeparator)||t))}sliceDoc(e=0,t=this.doc.length){return this.doc.sliceString(e,t,this.lineBreak)}facet(e){let t=this.config.address[e.id];if(t==null)return e.default;ensureAddr(this,t);return getAddr(this,t)}toJSON(e){let t={doc:this.sliceDoc(),selection:this.selection.toJSON()};if(e)for(let n in e){let i=e[n];i instanceof StateField&&this.config.address[i.id]!=null&&(t[n]=i.spec.toJSON(this.field(e[n]),this))}return t}static fromJSON(e,t={},n){if(!e||typeof e.doc!="string")throw new RangeError("Invalid JSON representation for EditorState");let i=[];if(n)for(let t in n)if(Object.prototype.hasOwnProperty.call(e,t)){let s=n[t],r=e[t];i.push(s.init((e=>s.spec.fromJSON(r,e))))}return EditorState.create({doc:e.doc,selection:EditorSelection.fromJSON(e.selection),extensions:t.extensions?i.concat([t.extensions]):i})}static create(e={}){let n=Configuration.resolve(e.extensions||[],new Map);let i=e.doc instanceof Text?e.doc:Text.of((e.doc||"").split(n.staticFacet(EditorState.lineSeparator)||t));let s=e.selection?e.selection instanceof EditorSelection?e.selection:EditorSelection.single(e.selection.anchor,e.selection.head):EditorSelection.single(0);checkSelection(s,i.length);n.staticFacet(l)||(s=s.asSingle());return new EditorState(n,i,s,n.dynamicSlots.map((()=>null)),((e,t)=>t.create(e)),null)}get tabSize(){return this.facet(EditorState.tabSize)}get lineBreak(){return this.facet(EditorState.lineSeparator)||"\n"}get readOnly(){return this.facet(d)}phrase(e,...t){for(let t of this.facet(EditorState.phrases))if(Object.prototype.hasOwnProperty.call(t,e)){e=t[e];break}t.length&&(e=e.replace(/\$(\$|\d*)/g,((e,n)=>{if(n=="$")return"$";let i=+(n||1);return!i||i>t.length?e:t[i-1]})));return e}languageDataAt(e,t,n=-1){let i=[];for(let s of this.facet(o))for(let r of s(this,t,n))Object.prototype.hasOwnProperty.call(r,e)&&i.push(r[e]);return i}charCategorizer(e){return makeCategorizer(this.languageDataAt("wordChars",e).join(""))}wordAt(e){let{text:t,from:n,length:i}=this.doc.lineAt(e);let s=this.charCategorizer(e);let r=e-n,a=e-n;while(r>0){let e=findClusterBreak(t,r,false);if(s(t.slice(e,r))!=p.Word)break;r=e}while(a<i){let e=findClusterBreak(t,a);if(s(t.slice(a,e))!=p.Word)break;a=e}return r==a?null:EditorSelection.range(r+n,a+n)}}EditorState.allowMultipleSelections=l;EditorState.tabSize=Facet.define({combine:e=>e.length?e[0]:4});EditorState.lineSeparator=h;EditorState.readOnly=d;EditorState.phrases=Facet.define({compare(e,t){let n=Object.keys(e),i=Object.keys(t);return n.length==i.length&&n.every((n=>e[n]==t[n]))}});EditorState.languageData=o;EditorState.changeFilter=c;EditorState.transactionFilter=f;EditorState.transactionExtender=u;Compartment.reconfigure=StateEffect.define();function combineConfig(e,t,n={}){let i={};for(let t of e)for(let e of Object.keys(t)){let s=t[e],r=i[e];if(r===void 0)i[e]=s;else if(r===s||s===void 0);else{if(!Object.hasOwnProperty.call(n,e))throw new Error("Config merge conflict for field "+e);i[e]=n[e](r,s)}}for(let e in t)i[e]===void 0&&(i[e]=t[e]);return i}class RangeValue{eq(e){return this==e}range(e,t=e){return Range.create(e,t,this)}}RangeValue.prototype.startSide=RangeValue.prototype.endSide=0;RangeValue.prototype.point=false;RangeValue.prototype.mapMode=n.TrackDel;class Range{constructor(e,t,n){this.from=e;this.to=t;this.value=n}static create(e,t,n){return new Range(e,t,n)}}function cmpRange(e,t){return e.from-t.from||e.value.startSide-t.value.startSide}class Chunk{constructor(e,t,n,i){this.from=e;this.to=t;this.value=n;this.maxPoint=i}get length(){return this.to[this.to.length-1]}findIndex(e,t,n,i=0){let s=n?this.to:this.from;for(let r=i,a=s.length;;){if(r==a)return r;let i=r+a>>1;let o=s[i]-e||(n?this.value[i].endSide:this.value[i].startSide)-t;if(i==r)return o>=0?r:a;o>=0?a=i:r=i+1}}between(e,t,n,i){for(let s=this.findIndex(t,-1e9,true),r=this.findIndex(n,1e9,false,s);s<r;s++)if(i(this.from[s]+e,this.to[s]+e,this.value[s])===false)return false}map(e,t){let n=[],i=[],s=[],r=-1,a=-1;for(let o=0;o<this.value.length;o++){let l,h,c=this.value[o],f=this.from[o]+e,u=this.to[o]+e;if(f==u){let e=t.mapPos(f,c.startSide,c.mapMode);if(e==null)continue;l=h=e;if(c.startSide!=c.endSide){h=t.mapPos(f,c.endSide);if(h<l)continue}}else{l=t.mapPos(f,c.startSide);h=t.mapPos(u,c.endSide);if(l>h||l==h&&c.startSide>0&&c.endSide<=0)continue}if(!((h-l||c.endSide-c.startSide)<0)){r<0&&(r=l);c.point&&(a=Math.max(a,h-l));n.push(c);i.push(l-r);s.push(h-r)}}return{mapped:n.length?new Chunk(i,s,n,a):null,pos:r}}}class RangeSet{constructor(e,t,n,i){this.chunkPos=e;this.chunk=t;this.nextLayer=n;this.maxPoint=i}static create(e,t,n,i){return new RangeSet(e,t,n,i)}get length(){let e=this.chunk.length-1;return e<0?0:Math.max(this.chunkEnd(e),this.nextLayer.length)}get size(){if(this.isEmpty)return 0;let e=this.nextLayer.size;for(let t of this.chunk)e+=t.value.length;return e}chunkEnd(e){return this.chunkPos[e]+this.chunk[e].length}update(e){let{add:t=[],sort:n=false,filterFrom:i=0,filterTo:s=this.length}=e;let r=e.filter;if(t.length==0&&!r)return this;n&&(t=t.slice().sort(cmpRange));if(this.isEmpty)return t.length?RangeSet.of(t):this;let a=new LayerCursor(this,null,-1).goto(0),o=0,l=[];let h=new RangeSetBuilder;while(a.value||o<t.length)if(o<t.length&&(a.from-t[o].from||a.startSide-t[o].value.startSide)>=0){let e=t[o++];h.addInner(e.from,e.to,e.value)||l.push(e)}else if(a.rangeIndex==1&&a.chunkIndex<this.chunk.length&&(o==t.length||this.chunkEnd(a.chunkIndex)<t[o].from)&&(!r||i>this.chunkEnd(a.chunkIndex)||s<this.chunkPos[a.chunkIndex])&&h.addChunk(this.chunkPos[a.chunkIndex],this.chunk[a.chunkIndex]))a.nextChunk();else{(!r||i>a.to||s<a.from||r(a.from,a.to,a.value))&&(h.addInner(a.from,a.to,a.value)||l.push(Range.create(a.from,a.to,a.value)));a.next()}return h.finishInner(this.nextLayer.isEmpty&&!l.length?RangeSet.empty:this.nextLayer.update({add:l,filter:r,filterFrom:i,filterTo:s}))}map(e){if(e.empty||this.isEmpty)return this;let t=[],n=[],i=-1;for(let s=0;s<this.chunk.length;s++){let r=this.chunkPos[s],a=this.chunk[s];let o=e.touchesRange(r,r+a.length);if(o===false){i=Math.max(i,a.maxPoint);t.push(a);n.push(e.mapPos(r))}else if(o===true){let{mapped:s,pos:o}=a.map(r,e);if(s){i=Math.max(i,s.maxPoint);t.push(s);n.push(o)}}}let s=this.nextLayer.map(e);return t.length==0?s:new RangeSet(n,t,s||RangeSet.empty,i)}between(e,t,n){if(!this.isEmpty){for(let i=0;i<this.chunk.length;i++){let s=this.chunkPos[i],r=this.chunk[i];if(t>=s&&e<=s+r.length&&r.between(s,e-s,t-s,n)===false)return}this.nextLayer.between(e,t,n)}}iter(e=0){return HeapCursor.from([this]).goto(e)}get isEmpty(){return this.nextLayer==this}static iter(e,t=0){return HeapCursor.from(e).goto(t)}static compare(e,t,n,i,s=-1){let r=e.filter((e=>e.maxPoint>0||!e.isEmpty&&e.maxPoint>=s));let a=t.filter((e=>e.maxPoint>0||!e.isEmpty&&e.maxPoint>=s));let o=findSharedChunks(r,a,n);let l=new SpanCursor(r,o,s);let h=new SpanCursor(a,o,s);n.iterGaps(((e,t,n)=>compare(l,e,h,t,n,i)));n.empty&&n.length==0&&compare(l,0,h,0,0,i)}static eq(e,t,n=0,i){i==null&&(i=999999999);let s=e.filter((e=>!e.isEmpty&&t.indexOf(e)<0));let r=t.filter((t=>!t.isEmpty&&e.indexOf(t)<0));if(s.length!=r.length)return false;if(!s.length)return true;let a=findSharedChunks(s,r);let o=new SpanCursor(s,a,0).goto(n),l=new SpanCursor(r,a,0).goto(n);for(;;){if(o.to!=l.to||!sameValues(o.active,l.active)||o.point&&(!l.point||!o.point.eq(l.point)))return false;if(o.to>i)return true;o.next();l.next()}}static spans(e,t,n,i,s=-1){let r=new SpanCursor(e,null,s).goto(t),a=t;let o=r.openStart;for(;;){let e=Math.min(r.to,n);if(r.point){let n=r.activeForPoint(r.to);let s=r.pointFrom<t?n.length+1:r.point.startSide<0?n.length:Math.min(n.length,o);i.point(a,e,r.point,n,s,r.pointRank);o=Math.min(r.openEnd(e),n.length)}else if(e>a){i.span(a,e,r.active,o);o=r.openEnd(e)}if(r.to>n)return o+(r.point&&r.to>n?1:0);a=r.to;r.next()}}static of(e,t=false){let n=new RangeSetBuilder;for(let i of e instanceof Range?[e]:t?lazySort(e):e)n.add(i.from,i.to,i.value);return n.finish()}static join(e){if(!e.length)return RangeSet.empty;let t=e[e.length-1];for(let n=e.length-2;n>=0;n--)for(let i=e[n];i!=RangeSet.empty;i=i.nextLayer)t=new RangeSet(i.chunkPos,i.chunk,t,Math.max(i.maxPoint,t.maxPoint));return t}}RangeSet.empty=new RangeSet([],[],null,-1);function lazySort(e){if(e.length>1)for(let t=e[0],n=1;n<e.length;n++){let i=e[n];if(cmpRange(t,i)>0)return e.slice().sort(cmpRange);t=i}return e}RangeSet.empty.nextLayer=RangeSet.empty;class RangeSetBuilder{finishChunk(e){this.chunks.push(new Chunk(this.from,this.to,this.value,this.maxPoint));this.chunkPos.push(this.chunkStart);this.chunkStart=-1;this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint);this.maxPoint=-1;if(e){this.from=[];this.to=[];this.value=[]}}constructor(){this.chunks=[];this.chunkPos=[];this.chunkStart=-1;this.last=null;this.lastFrom=-1e9;this.lastTo=-1e9;this.from=[];this.to=[];this.value=[];this.maxPoint=-1;this.setMaxPoint=-1;this.nextLayer=null}add(e,t,n){this.addInner(e,t,n)||(this.nextLayer||(this.nextLayer=new RangeSetBuilder)).add(e,t,n)}addInner(e,t,n){let i=e-this.lastTo||n.startSide-this.last.endSide;if(i<=0&&(e-this.lastFrom||n.startSide-this.last.startSide)<0)throw new Error("Ranges must be added sorted by `from` position and `startSide`");if(i<0)return false;this.from.length==250&&this.finishChunk(true);this.chunkStart<0&&(this.chunkStart=e);this.from.push(e-this.chunkStart);this.to.push(t-this.chunkStart);this.last=n;this.lastFrom=e;this.lastTo=t;this.value.push(n);n.point&&(this.maxPoint=Math.max(this.maxPoint,t-e));return true}addChunk(e,t){if((e-this.lastTo||t.value[0].startSide-this.last.endSide)<0)return false;this.from.length&&this.finishChunk(true);this.setMaxPoint=Math.max(this.setMaxPoint,t.maxPoint);this.chunks.push(t);this.chunkPos.push(e);let n=t.value.length-1;this.last=t.value[n];this.lastFrom=t.from[n]+e;this.lastTo=t.to[n]+e;return true}finish(){return this.finishInner(RangeSet.empty)}finishInner(e){this.from.length&&this.finishChunk(false);if(this.chunks.length==0)return e;let t=RangeSet.create(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(e):e,this.setMaxPoint);this.from=null;return t}}function findSharedChunks(e,t,n){let i=new Map;for(let t of e)for(let e=0;e<t.chunk.length;e++)t.chunk[e].maxPoint<=0&&i.set(t.chunk[e],t.chunkPos[e]);let s=new Set;for(let e of t)for(let t=0;t<e.chunk.length;t++){let r=i.get(e.chunk[t]);r==null||(n?n.mapPos(r):r)!=e.chunkPos[t]||(n===null||n===void 0?void 0:n.touchesRange(r,r+e.chunk[t].length))||s.add(e.chunk[t])}return s}class LayerCursor{constructor(e,t,n,i=0){this.layer=e;this.skip=t;this.minPoint=n;this.rank=i}get startSide(){return this.value?this.value.startSide:0}get endSide(){return this.value?this.value.endSide:0}goto(e,t=-1e9){this.chunkIndex=this.rangeIndex=0;this.gotoInner(e,t,false);return this}gotoInner(e,t,n){while(this.chunkIndex<this.layer.chunk.length){let t=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(t)||this.layer.chunkEnd(this.chunkIndex)<e||t.maxPoint<this.minPoint))break;this.chunkIndex++;n=false}if(this.chunkIndex<this.layer.chunk.length){let i=this.layer.chunk[this.chunkIndex].findIndex(e-this.layer.chunkPos[this.chunkIndex],t,true);(!n||this.rangeIndex<i)&&this.setRangeIndex(i)}this.next()}forward(e,t){(this.to-e||this.endSide-t)<0&&this.gotoInner(e,t,true)}next(){for(;;){if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1e9;this.value=null;break}{let e=this.layer.chunkPos[this.chunkIndex],t=this.layer.chunk[this.chunkIndex];let n=e+t.from[this.rangeIndex];this.from=n;this.to=e+t.to[this.rangeIndex];this.value=t.value[this.rangeIndex];this.setRangeIndex(this.rangeIndex+1);if(this.minPoint<0||this.value.point&&this.to-this.from>=this.minPoint)break}}}setRangeIndex(e){if(e==this.layer.chunk[this.chunkIndex].value.length){this.chunkIndex++;if(this.skip)while(this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]))this.chunkIndex++;this.rangeIndex=0}else this.rangeIndex=e}nextChunk(){this.chunkIndex++;this.rangeIndex=0;this.next()}compare(e){return this.from-e.from||this.startSide-e.startSide||this.rank-e.rank||this.to-e.to||this.endSide-e.endSide}}class HeapCursor{constructor(e){this.heap=e}static from(e,t=null,n=-1){let i=[];for(let s=0;s<e.length;s++)for(let r=e[s];!r.isEmpty;r=r.nextLayer)r.maxPoint>=n&&i.push(new LayerCursor(r,t,n,s));return i.length==1?i[0]:new HeapCursor(i)}get startSide(){return this.value?this.value.startSide:0}goto(e,t=-1e9){for(let n of this.heap)n.goto(e,t);for(let e=this.heap.length>>1;e>=0;e--)heapBubble(this.heap,e);this.next();return this}forward(e,t){for(let n of this.heap)n.forward(e,t);for(let e=this.heap.length>>1;e>=0;e--)heapBubble(this.heap,e);(this.to-e||this.value.endSide-t)<0&&this.next()}next(){if(this.heap.length==0){this.from=this.to=1e9;this.value=null;this.rank=-1}else{let e=this.heap[0];this.from=e.from;this.to=e.to;this.value=e.value;this.rank=e.rank;e.value&&e.next();heapBubble(this.heap,0)}}}function heapBubble(e,t){for(let n=e[t];;){let i=1+(t<<1);if(i>=e.length)break;let s=e[i];if(i+1<e.length&&s.compare(e[i+1])>=0){s=e[i+1];i++}if(n.compare(s)<0)break;e[i]=n;e[t]=s;t=i}}class SpanCursor{constructor(e,t,n){this.minPoint=n;this.active=[];this.activeTo=[];this.activeRank=[];this.minActive=-1;this.point=null;this.pointFrom=0;this.pointRank=0;this.to=-1e9;this.endSide=0;this.openStart=-1;this.cursor=HeapCursor.from(e,t,n)}goto(e,t=-1e9){this.cursor.goto(e,t);this.active.length=this.activeTo.length=this.activeRank.length=0;this.minActive=-1;this.to=e;this.endSide=t;this.openStart=-1;this.next();return this}forward(e,t){while(this.minActive>-1&&(this.activeTo[this.minActive]-e||this.active[this.minActive].endSide-t)<0)this.removeActive(this.minActive);this.cursor.forward(e,t)}removeActive(e){remove(this.active,e);remove(this.activeTo,e);remove(this.activeRank,e);this.minActive=findMinIndex(this.active,this.activeTo)}addActive(e){let t=0,{value:n,to:i,rank:s}=this.cursor;while(t<this.activeRank.length&&(s-this.activeRank[t]||i-this.activeTo[t])>0)t++;insert(this.active,t,n);insert(this.activeTo,t,i);insert(this.activeRank,t,s);e&&insert(e,t,this.cursor.from);this.minActive=findMinIndex(this.active,this.activeTo)}next(){let e=this.to,t=this.point;this.point=null;let n=this.openStart<0?[]:null;for(;;){let i=this.minActive;if(i>-1&&(this.activeTo[i]-this.cursor.from||this.active[i].endSide-this.cursor.startSide)<0){if(this.activeTo[i]>e){this.to=this.activeTo[i];this.endSide=this.active[i].endSide;break}this.removeActive(i);n&&remove(n,i)}else{if(!this.cursor.value){this.to=this.endSide=1e9;break}if(this.cursor.from>e){this.to=this.cursor.from;this.endSide=this.cursor.startSide;break}{let e=this.cursor.value;if(e.point){if(!(t&&this.cursor.to==this.to&&this.cursor.from<this.cursor.to)){this.point=e;this.pointFrom=this.cursor.from;this.pointRank=this.cursor.rank;this.to=this.cursor.to;this.endSide=e.endSide;this.cursor.next();this.forward(this.to,this.endSide);break}this.cursor.next()}else{this.addActive(n);this.cursor.next()}}}}if(n){this.openStart=0;for(let t=n.length-1;t>=0&&n[t]<e;t--)this.openStart++}}activeForPoint(e){if(!this.active.length)return this.active;let t=[];for(let n=this.active.length-1;n>=0;n--){if(this.activeRank[n]<this.pointRank)break;(this.activeTo[n]>e||this.activeTo[n]==e&&this.active[n].endSide>=this.point.endSide)&&t.push(this.active[n])}return t.reverse()}openEnd(e){let t=0;for(let n=this.activeTo.length-1;n>=0&&this.activeTo[n]>e;n--)t++;return t}}function compare(e,t,n,i,s,r){e.goto(t);n.goto(i);let a=i+s;let o=i,l=i-t;for(;;){let t=e.to+l-n.to,i=t||e.endSide-n.endSide;let s=i<0?e.to+l:n.to,h=Math.min(s,a);e.point||n.point?e.point&&n.point&&(e.point==n.point||e.point.eq(n.point))&&sameValues(e.activeForPoint(e.to),n.activeForPoint(n.to))||r.comparePoint(o,h,e.point,n.point):h>o&&!sameValues(e.active,n.active)&&r.compareRange(o,h,e.active,n.active);if(s>a)break;(t||e.openEnd!=n.openEnd)&&r.boundChange&&r.boundChange(s);o=s;i<=0&&e.next();i>=0&&n.next()}}function sameValues(e,t){if(e.length!=t.length)return false;for(let n=0;n<e.length;n++)if(e[n]!=t[n]&&!e[n].eq(t[n]))return false;return true}function remove(e,t){for(let n=t,i=e.length-1;n<i;n++)e[n]=e[n+1];e.pop()}function insert(e,t,n){for(let n=e.length-1;n>=t;n--)e[n+1]=e[n];e[t]=n}function findMinIndex(e,t){let n=-1,i=1e9;for(let s=0;s<t.length;s++)if((t[s]-i||e[s].endSide-e[n].endSide)<0){n=s;i=t[s]}return n}function countColumn(e,t,n=e.length){let i=0;for(let s=0;s<n&&s<e.length;)if(e.charCodeAt(s)==9){i+=t-i%t;s++}else{i++;s=findClusterBreak(e,s)}return i}function findColumn(e,t,n,i){for(let i=0,s=0;;){if(s>=t)return i;if(i==e.length)break;s+=e.charCodeAt(i)==9?n-s%n:1;i=findClusterBreak(e,i)}return i===true?-1:e.length}export{Annotation,AnnotationType,ChangeDesc,ChangeSet,p as CharCategory,Compartment,EditorSelection,EditorState,Facet,Line,n as MapMode,a as Prec,Range,RangeSet,RangeSetBuilder,RangeValue,SelectionRange,StateEffect,StateEffectType,StateField,Text,Transaction,codePointAt,codePointSize,combineConfig,countColumn,findClusterBreak,findColumn,fromCodePoint};

