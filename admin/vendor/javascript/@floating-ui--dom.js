// @floating-ui/dom@1.7.4 downloaded from https://ga.jspm.io/npm:@floating-ui/dom@1.7.4/dist/floating-ui.dom.mjs

import{rectToClientRect as t,detectOverflow as e,offset as n,autoPlacement as o,shift as i,flip as s,size as c,hide as r,arrow as l,inline as f,limitShift as u,computePosition as h}from"@floating-ui/core";import{round as a,createCoords as d,max as g,min as p,floor as m}from"@floating-ui/utils";import{getComputedStyle as y,isHTMLElement as x,isElement as w,getWindow as v,isWebKit as b,getFrameElement as R,getNodeScroll as L,getDocumentElement as T,isTopLayer as C,getNodeName as F,isOverflowElement as W,getParentNode as E,isLastTraversableNode as O,getOverflowAncestors as S,isContainingBlock as H,isTableElement as z,getContainingBlock as A}from"@floating-ui/utils/dom";export{getOverflowAncestors}from"@floating-ui/utils/dom";function B(t){const e=y(t);let n=parseFloat(e.width)||0;let o=parseFloat(e.height)||0;const i=x(t);const s=i?t.offsetWidth:n;const c=i?t.offsetHeight:o;const r=a(n)!==s||a(o)!==c;if(r){n=s;o=c}return{width:n,height:o,$:r}}function D(t){return w(t)?t:t.contextElement}function P(t){const e=D(t);if(!x(e))return d(1);const n=e.getBoundingClientRect();const{width:o,height:i,$:s}=B(e);let c=(s?a(n.width):n.width)/o;let r=(s?a(n.height):n.height)/i;c&&Number.isFinite(c)||(c=1);r&&Number.isFinite(r)||(r=1);return{x:c,y:r}}const V=d(0);function M(t){const e=v(t);return b()&&e.visualViewport?{x:e.visualViewport.offsetLeft,y:e.visualViewport.offsetTop}:V}function I(t,e,n){e===void 0&&(e=false);return!(!n||e&&n!==v(t))&&e}function q(e,n,o,i){n===void 0&&(n=false);o===void 0&&(o=false);const s=e.getBoundingClientRect();const c=D(e);let r=d(1);n&&(i?w(i)&&(r=P(i)):r=P(e));const l=I(c,o,i)?M(c):d(0);let f=(s.left+l.x)/r.x;let u=(s.top+l.y)/r.y;let h=s.width/r.x;let a=s.height/r.y;if(c){const t=v(c);const e=i&&w(i)?v(i):i;let n=t;let o=R(n);while(o&&i&&e!==n){const t=P(o);const e=o.getBoundingClientRect();const i=y(o);const s=e.left+(o.clientLeft+parseFloat(i.paddingLeft))*t.x;const c=e.top+(o.clientTop+parseFloat(i.paddingTop))*t.y;f*=t.x;u*=t.y;h*=t.x;a*=t.y;f+=s;u+=c;n=v(o);o=R(n)}}return t({width:h,height:a,x:f,y:u})}function N(t,e){const n=L(t).scrollLeft;return e?e.left+n:q(T(t)).left+n}function $(t,e){const n=t.getBoundingClientRect();const o=n.left+e.scrollLeft-N(t,n);const i=n.top+e.scrollTop;return{x:o,y:i}}function _(t){let{elements:e,rect:n,offsetParent:o,strategy:i}=t;const s=i==="fixed";const c=T(o);const r=!!e&&C(e.floating);if(o===c||r&&s)return n;let l={scrollLeft:0,scrollTop:0};let f=d(1);const u=d(0);const h=x(o);if(h||!h&&!s){(F(o)!=="body"||W(c))&&(l=L(o));if(x(o)){const t=q(o);f=P(o);u.x=t.x+o.clientLeft;u.y=t.y+o.clientTop}}const a=!c||h||s?d(0):$(c,l);return{width:n.width*f.x,height:n.height*f.y,x:n.x*f.x-l.scrollLeft*f.x+u.x+a.x,y:n.y*f.y-l.scrollTop*f.y+u.y+a.y}}function j(t){return Array.from(t.getClientRects())}function k(t){const e=T(t);const n=L(t);const o=t.ownerDocument.body;const i=g(e.scrollWidth,e.clientWidth,o.scrollWidth,o.clientWidth);const s=g(e.scrollHeight,e.clientHeight,o.scrollHeight,o.clientHeight);let c=-n.scrollLeft+N(t);const r=-n.scrollTop;y(o).direction==="rtl"&&(c+=g(e.clientWidth,o.clientWidth)-i);return{width:i,height:s,x:c,y:r}}const G=25;function J(t,e){const n=v(t);const o=T(t);const i=n.visualViewport;let s=o.clientWidth;let c=o.clientHeight;let r=0;let l=0;if(i){s=i.width;c=i.height;const t=b();if(!t||t&&e==="fixed"){r=i.offsetLeft;l=i.offsetTop}}const f=N(o);if(f<=0){const t=o.ownerDocument;const e=t.body;const n=getComputedStyle(e);const i=t.compatMode==="CSS1Compat"&&parseFloat(n.marginLeft)+parseFloat(n.marginRight)||0;const c=Math.abs(o.clientWidth-e.clientWidth-i);c<=G&&(s-=c)}else f<=G&&(s+=f);return{width:s,height:c,x:r,y:l}}const K=new Set(["absolute","fixed"]);function Q(t,e){const n=q(t,true,e==="fixed");const o=n.top+t.clientTop;const i=n.left+t.clientLeft;const s=x(t)?P(t):d(1);const c=t.clientWidth*s.x;const r=t.clientHeight*s.y;const l=i*s.x;const f=o*s.y;return{width:c,height:r,x:l,y:f}}function U(e,n,o){let i;if(n==="viewport")i=J(e,o);else if(n==="document")i=k(T(e));else if(w(n))i=Q(n,o);else{const t=M(e);i={x:n.x-t.x,y:n.y-t.y,width:n.width,height:n.height}}return t(i)}function X(t,e){const n=E(t);return!(n===e||!w(n)||O(n))&&(y(n).position==="fixed"||X(n,e))}function Y(t,e){const n=e.get(t);if(n)return n;let o=S(t,[],false).filter((t=>w(t)&&F(t)!=="body"));let i=null;const s=y(t).position==="fixed";let c=s?E(t):t;while(w(c)&&!O(c)){const e=y(c);const n=H(c);n||e.position!=="fixed"||(i=null);const r=s?!n&&!i:!n&&e.position==="static"&&!!i&&K.has(i.position)||W(c)&&!n&&X(t,c);r?o=o.filter((t=>t!==c)):i=e;c=E(c)}e.set(t,o);return o}function Z(t){let{element:e,boundary:n,rootBoundary:o,strategy:i}=t;const s=n==="clippingAncestors"?C(e)?[]:Y(e,this._c):[].concat(n);const c=[...s,o];const r=c[0];const l=c.reduce(((t,n)=>{const o=U(e,n,i);t.top=g(o.top,t.top);t.right=p(o.right,t.right);t.bottom=p(o.bottom,t.bottom);t.left=g(o.left,t.left);return t}),U(e,r,i));return{width:l.right-l.left,height:l.bottom-l.top,x:l.left,y:l.top}}function tt(t){const{width:e,height:n}=B(t);return{width:e,height:n}}function et(t,e,n){const o=x(e);const i=T(e);const s=n==="fixed";const c=q(t,true,s,e);let r={scrollLeft:0,scrollTop:0};const l=d(0);function f(){l.x=N(i)}if(o||!o&&!s){(F(e)!=="body"||W(i))&&(r=L(e));if(o){const t=q(e,true,s,e);l.x=t.x+e.clientLeft;l.y=t.y+e.clientTop}else i&&f()}s&&!o&&i&&f();const u=!i||o||s?d(0):$(i,r);const h=c.left+r.scrollLeft-l.x-u.x;const a=c.top+r.scrollTop-l.y-u.y;return{x:h,y:a,width:c.width,height:c.height}}function nt(t){return y(t).position==="static"}function ot(t,e){if(!x(t)||y(t).position==="fixed")return null;if(e)return e(t);let n=t.offsetParent;T(t)===n&&(n=n.ownerDocument.body);return n}function it(t,e){const n=v(t);if(C(t))return n;if(!x(t)){let e=E(t);while(e&&!O(e)){if(w(e)&&!nt(e))return e;e=E(e)}return n}let o=ot(t,e);while(o&&z(o)&&nt(o))o=ot(o,e);return o&&O(o)&&nt(o)&&!H(o)?n:o||A(t)||n}const st=async function(t){const e=this.getOffsetParent||it;const n=this.getDimensions;const o=await n(t.floating);return{reference:et(t.reference,await e(t.floating),t.strategy),floating:{x:0,y:0,width:o.width,height:o.height}}};function ct(t){return y(t).direction==="rtl"}const rt={convertOffsetParentRelativeRectToViewportRelativeRect:_,getDocumentElement:T,getClippingRect:Z,getOffsetParent:it,getElementRects:st,getClientRects:j,getDimensions:tt,getScale:P,isElement:w,isRTL:ct};function lt(t,e){return t.x===e.x&&t.y===e.y&&t.width===e.width&&t.height===e.height}function ft(t,e){let n=null;let o;const i=T(t);function s(){var t;clearTimeout(o);(t=n)==null||t.disconnect();n=null}function c(r,l){r===void 0&&(r=false);l===void 0&&(l=1);s();const f=t.getBoundingClientRect();const{left:u,top:h,width:a,height:d}=f;r||e();if(!a||!d)return;const y=m(h);const x=m(i.clientWidth-(u+a));const w=m(i.clientHeight-(h+d));const v=m(u);const b=-y+"px "+-x+"px "+-w+"px "+-v+"px";const R={rootMargin:b,threshold:g(0,p(1,l))||1};let L=true;function T(e){const n=e[0].intersectionRatio;if(n!==l){if(!L)return c();n?c(false,n):o=setTimeout((()=>{c(false,1e-7)}),1e3)}n!==1||lt(f,t.getBoundingClientRect())||c();L=false}try{n=new IntersectionObserver(T,{...R,root:i.ownerDocument})}catch(t){n=new IntersectionObserver(T,R)}n.observe(t)}c(true);return s}
/**
 * Automatically updates the position of the floating element when necessary.
 * Should only be called when the floating element is mounted on the DOM or
 * visible on the screen.
 * @returns cleanup function that should be invoked when the floating element is
 * removed from the DOM or hidden from the screen.
 * @see https://floating-ui.com/docs/autoUpdate
 */function ut(t,e,n,o){o===void 0&&(o={});const{ancestorScroll:i=true,ancestorResize:s=true,elementResize:c=typeof ResizeObserver==="function",layoutShift:r=typeof IntersectionObserver==="function",animationFrame:l=false}=o;const f=D(t);const u=i||s?[...f?S(f):[],...S(e)]:[];u.forEach((t=>{i&&t.addEventListener("scroll",n,{passive:true});s&&t.addEventListener("resize",n)}));const h=f&&r?ft(f,n):null;let a=-1;let d=null;if(c){d=new ResizeObserver((t=>{let[o]=t;if(o&&o.target===f&&d){d.unobserve(e);cancelAnimationFrame(a);a=requestAnimationFrame((()=>{var t;(t=d)==null||t.observe(e)}))}n()}));f&&!l&&d.observe(f);d.observe(e)}let g;let p=l?q(t):null;l&&m();function m(){const e=q(t);p&&!lt(p,e)&&n();p=e;g=requestAnimationFrame(m)}n();return()=>{var t;u.forEach((t=>{i&&t.removeEventListener("scroll",n);s&&t.removeEventListener("resize",n)}));h==null||h();(t=d)==null||t.disconnect();d=null;l&&cancelAnimationFrame(g)}}const ht=e;const at=n;const dt=o;const gt=i;const pt=s;const mt=c;const yt=r;const xt=l;const wt=f;const vt=u;const bt=(t,e,n)=>{const o=new Map;const i={platform:rt,...n};const s={...i.platform,_c:o};return h(t,e,{...i,platform:s})};export{xt as arrow,dt as autoPlacement,ut as autoUpdate,bt as computePosition,ht as detectOverflow,pt as flip,yt as hide,wt as inline,vt as limitShift,at as offset,rt as platform,gt as shift,mt as size};

