h2. Checkout Process

This guide covers the design of the checkout process and how to modify it.
After reading it, you should be familiar with:

* The basic architecture underlying the checkout code
* The functionality provided by the checkout system
* How to customize the logic or views for an existing checkout step
* How to add or remove steps to the checkout process

endprologue.

INFO. The checkout process has been recently modified.  Previously, the checkout was a single page checkout which required javascript.  The new checkout is a multi-step, multi page process which does not require javascript.  We're currently looking into restoring the single page checkout as an option, but for now, that's left as an exercise to the developer.

h3. Overview

The Spree checkout process has been designed for maximum flexibility.  Its been redesigned several times now, each iteration has benefited from the feedback of real world deployment experience.  It is relatively simple to customize the checkout process to suit your needs.  Secure transmission of customer information is possible via SSL and credit card information is not stored in the database by default.

h3. General Design

In Spree, the +Checkout+ is modeled as its own object which belongs to an +Order+.  The checkout steps themselves are modeled through the "state_machine":http://github.com/pluginaweek/state_machine gem.  You can define your own custom checkout "flow" by defining a new state machine in your "site extension":extensions.html#site-extension.  The Spree data model does not have a separate model or database table for the shopping cart.  We reached this decision when taking a REST approach to modeling our resources.  What the user considers a "shopping cart" is actually an +Order+ with a state of "in progress."  Incomplete orders can be easily filtered during reporting and its also simple enough to write a quick script to periodically purge incomplete orders from the system.  The end result is a simplified data model along with the ability for store owners to search and report on incomplete/abandoned orders.

The +CheckoutsController+ takes advantage of the "resource_controller":http://github.com/jamesgolick/resource_controller plugin (just like most of the controllers in Spree.)  It has been designed so that you can provide your own controller logic without overriding the entire class.  Please see the later section on customization for further details.

Multi step checkout also poses some technical challenges when it comes to validation.  By default, Rails will validate your model objects every time they are saved.  In the checkout case, however, you are basically updating a +Checkout+ model one page at a time so you do not expect to have a "valid" model until the very last step.  We solve this problem by introducing the concept of a +ValidationGroup+ which allows you to define a series of fields that need to validated for any one particular step.

h3. Default Checkout Process

The Spree checkout process consists of the following steps:

* Registration
* Address Information
* Delivery Options (Shipping Method)
* Payment 

There is also a default progress "train" which shows the current step and allows you to jump back to a previous step by clicking on it.

h4. Registration

Prior to beginning the checkout process, the customer will be prompted to create a new account or to login to their existing account. By default, there is also a "guest checkout" option which allows users to specify only their email address if they do not wish to create an account.  It is also possible to disable the registration step entirely for true "anonymous" checkout in those rare edge cases where you would be able to process the order without an email address.

The registration step is not actually part of the checkout "state machine."  The +enforce_registration+ method of the  +CheckoutsController+ provides this functionality:

<ruby>
def enforce_registration
  return if current_user or Spree::Config[:allow_anonymous_checkout]
  return if Spree::Config[:allow_guest_checkout] and object.email.present?
  store_location
  redirect_to register_order_checkout_url(parent_object)
end  
</ruby>

The configuration of the guest and anonymous checkout options is done via "preferences":preferences.html.  Spree will allow guest checkout and disallow anonymous checkout (which is typically not needed) by default. Use the +allow_guest_checkout+ and +allow_anonymous_checkout+ preferences to change the default settings.

NOTE. If you are only interested in supporting guest checkout you may want to configure Spree for anonymous checkout and then incorporate the email into another step.  This will effectively skip the registration page and allow you to capture the email on a different form.

h4. Address Information

This step allows the customer to add both their billing and shipping information.  Customers can click the "use billing address" option to use the same address for both.  Selecting this option will have the effect of hiding the shipping address fields using javascript.  If users have disabled javascript, the section will not disappear but it will copy over the address information once submitted.  If you would like to automatically copy the address information via javascript on the client side, that is an exercise left to the developer.  We have found the server side approach to be simpler and easier to maintain.

The address fields include a select box for choosing state/province.  The list of states will be populated via javascript and will contain all of the states listed in the database for the currently selected country.  If there are no states configured for a particular country, or if the user has javascript disabled, the select box will be replaced by a text field instead. 

INFO. The default "seed" data for Spree only includes the U.S. states.  Its easy enough to add states or provinces for other countries but beyond the scope of the project to maintain such a list.  Feel free to add your own seed data for the states you require (and to share your seed scripts with others via "Gist":http://gist.github.com.) 

NOTE. The state field can be disabled entirely by using the +address_requires_state+ preference.  You can also allow for an "alternate phone" field by using the +alternative_billing_phone+ and +alternative_shipping+ fields.

The list of countries that appear in the country select box can also be configured.  Spree will list all countries by default but you can configure exactly which countries you would like to appear.  The list can be limited to a specific set of countries by configuring the new +:checkout_zone+ preference and setting its value to the name of a "zone":/zones.html containing the countries you wish to use.  Spree assumes that the list of billing and shipping countries will be the same.  You can always change this logic via an extension if this does not suit your needs.

h4. Delivery Options

The next step is for the customer to choose their shipping method.  Spree assumes the list of shipping methods to be dependent on the shipping address.  This is one of the reasons why it is difficult to support single page checkout for customers who have disabled javascript.  Spree allows you to configure any number of custom "shipping methods":shipping.html.  Each shipping method must be configured with a "zone":zones.html.  The available shipping methods shown during this step will reflect those whose zone overlaps with the specified shipping address.  The shipping methods will also list the associated shipping charge based on the logic provided by their "calculators":calculators.html.

INFO. You must configure at least one shipping method and corresponding zone in order to show shipping methods during checkout.

NOTE. The delivery step is an excellent place to add information on gift options (wrapping paper, etc.)  See the "gift-options":http://github.com/calas/spree-gift-options extension for one possible implementation of this.

h4. Payment

The final step of the checkout process is payment.  This step is intentionally placed last in order to minimize security issues with credit card information.  Credit card information is never stored in the database so it would be impossible to have a subsequent step and still be able to submit the information to the "payment gateway":payment_gateways.html.  Spree submits the information to the gateway before saving the model so that the sensitive information can be discarded before saving the checkout information.

INFO. Spree stores only the last four digits of the credit card number along with the expiration information.  The full credit card number and verification code are never stored in the database.  This default behavior can be overwritten by setting the values of the +store_cc+ and +store_cvv+ preferences.  There is also an extension for storing this data using PGP encryption.  Both of these practices, however, violate PCI standards and are strongly discouraged.  They are intended primarily for use during development.

The payment step is the final opportunity to make changes to the order before it is submitted for processing.  This step also provides a summary of the order including "charges and other adjustments":coupons_and_discounts.html so the user can review this information before completing the transaction.

NOTE. Several gateways such as ActiveMerchant and Beanstream provide a secure method for storing a credit card "profile" in your database.  This approach typically involves the use of a "token" which can be used for subsequent purchases but only with your merchant account.  If you are using a secure payment profile it would then be possible to show a final "confirmation" step after payment information is entered.

h3. Customizing the Steps

h4. Checkout Architecture

The following is a detailed summary of the checkout architecture.  A complete understanding of this architecture will allow you to be able to customize the checkout process to handle just about any scenario you can think of.  Feel free to skip this section and come back to it later if you require a deeper understanding of the design in order to customize your checkout.

h5. The Checkout State Machine

The state machine is the foundation of the checkout process.  Spree makes use of the "state_machine":http://github.com/pluginaweek/state_machine gem in the +Checkout+ model as well as in several other places (such as +Order+, +Shipment+ and +InventoryUnit+.)

The default state machine is defined in +checkout.rb+ as follows:

<ruby>
state_machine :initial => 'address' do
  after_transition :to => 'complete', :do => :complete_order
  before_transition :to => 'complete', :do => :process_payment
  event :next do
    transition :to => 'delivery', :from  => 'address'
    transition :to => 'payment', :from => 'delivery'
    transition :to => 'complete', :from => 'payment'
  end
end
</ruby>

INFO. For more information on the state machine gem please see the "README":http://github.com/pluginaweek/state_machine

h5. Controller Logic

The +CheckoutsController+ makes use of the standard functionality provided by "resource_controller":http://github.com/jamesgolick/resource_controller.  As such, it is relatively "skinny":http://railsdog.com/blog/2009/07/resource-controller-for-skinny-rails-controllers considering how complex the business logic surrounding checkout can be.  The general concept behind the design of this specific controller is to treat +Checkout+ as its own resource and to perform basic update operations using the standard update mechanisms provided by Rails (used in conjunction with "nested attributes":http://guides.rubyonrails.org/2_3_release_notes#nested-attributes.) 

This controller also provides its own "hook mechanism" (not to be confused with theme hooks) which allow for the developer to perform additional logic (or to change the default) logic that is applied during the edit and/or update operation for a particular step.  The +Spree::Checkout::Hooks+ module provides this additional functionality and makes use of methods provided by the +resource_controller+ gem.  

The +CheckoutsController+ will automatically call an +edit_hook+ (if one is defined) before moving on to the standard edit functionality for a particular step.  There is also a corresponding +update_hook+ that can be used to execute additional functionality during an update.  Both hooks can accept either a symbol (which is the name of a method) or a block.

The +CheckoutsController+ itself makes limited use of these hooks - its expected that developers will add their own through a site extension.  Here's an example of an +edit_hook+ defined in +checkouts_controller.rb+:

<ruby>
delivery.edit_hook :load_available_methods 
</ruby> 

This tells the controller to call +load_available_methods+ before presenting the standard edit form for the delivery step.  The hook will be called only during the delivery step - it is ignored for all other steps.  This is necessary for the delivery step because we can't simply instantiate the +@checkout+ object and show the form.  We also need the list of available shipping methods for the specific address that is being requested.  The checkout hooks also support an alternate block syntax.  Using this syntax the same hook could have been defined as follows:

<ruby>
delivery.edit_hook do
  @available_methods = rate_hash
  @checkout.shipment.shipping_method_id ||= @available_methods.first[:id]
end
</ruby>

Both +edit_hook+ and +update_hook+ can be overridden entirely using either the symbol or block syntax.  What is the use case for overriding a hook?  The most obvious scenario would be to negate or remove functionality provided by the Spree core (or perhaps an extension which does almost exactly what you want.)  For instance, if you did not want to record the ip address when entering the address step.

<ruby>
# negate the default edit_hook functionality for the address step
address.edit_hook {} 
</ruby>

INFO. If you are skipping a step in the default checkout process the hooks will never be called for that step.  

WARNING. Be sure to check the documentation for any third party extensions you are using.  These extensions may introduce new steps or hooks and/or make assumptions about the availability of specific steps or hooks.

Perhaps more interestingly, hooks can also be appended to.  In other words, if you wanted to perform some additional logic before presenting the delivery form, you could add something like the following in your site extension.

<ruby>
delivery.edit_hook << :perform_additional_logic
</ruby> 

This is an argument for using the symbol approach instead of the block syntax.  It also makes it easier for extensions to work in tandem to customize the checkout process.  

Finally, you can also use the standard resource_controller hook mechanism for adding general functionality to the checkout process on edit or update.  For example:

<ruby>
edit.before << :something_before_editing_every_step
</ruby>

or you can also use the block syntax version

<ruby>
edit.before do
  # do something useful here
end
</ruby>

WARNING. Using the block syntax to replace the +resource_controller+ before hook would also have the effect of removing the custom +edit_hook+ functionality.  This is not recommended unless you are planning on creating a total custom checkout solution and you are not relying on any third party extensions to modify your checkout process.

Using the block syntax is destructive (it removes any previously defined hooks) and is suitable only in situations where you need to make drastic changes to the checkout process.

INFO. If you are writing a third party extension, be sure to also see the documentation for "adding and removing steps":#addingor-removing-steps.  There is an extra step to ensure that any new checkout steps added by your extension are also able to handle the special +edit_hook+ and +update_hook+ calls.  This will allow developers to further customize the step from within their site extension.

h5. Checkout Partials

The default theme contains several partials located within +vendor/extensions/theme_default/app/views/checkouts+.  Each checkout step automatically renders the +edit.html.erb+ view along with a corresponding partial based on the state associated with the current step.  For example, in the delivery step the +_delivery.html.erb+ partial is used.

h5. Javascript

Spree does not require javascript for checkout but the user experience will be slightly more pleasing if they have javascript enabled in their browser.  Spree automatically includes the +checkout.js+ file located in the default theme.  This file can be replaced in its entirety through use of a site extension.

h5. Checkout Styles

There are two stylesheet files used by the Spree checkout process.  Both +_checkout.less+ and +_checkout_progress.less+ can be found in the default theme.

[TODO - Add brief mention of and link to CSS customization using Less once that guide becomes available. ]

h4. Customizing an Existing Step

Spree allows you to customize the individual steps of the checkout process.  There are a few distinct scenarios that we'll cover here.

* Adding logic to the +CheckoutsController+ before or after a particular step.
* Customizing the view for a particular step.

h5. Adding Logic Before or After a Particular Step

Spree allows you to add logic in your controller before displaying the view/form for a particular step as well as after updating (posting) the information associated with a specific step.  Spree defines an +edit_hook+ and an +update_hook+ for just such situations.  

Lets say your payment view required that you populate an instance view in the controller before rendering.  You could do the following:

<ruby>
payment.edit_before do
  @foo = Foo.new(:bar => params[:bar])
end_
</ruby>

INFO. See the "controller logic":#controller-logic section for more details on the checkout hooks.

h5. Customizing the View for a Particular Step

Each of the default checkout steps has its own partial defined in the default theme.  Changing the view for an existing step is as simple as overriding the relevant partial in your site extension.  Its also possible the default partial in question defines a usable theme hook, in which case you could add your functionality via +hooks.rb+.

[TODO - Add link to hook theming writeup once complete]

INFO. See also the brief discussion in "checkout partials":#checkout-partials for additional information.

h4. Validation Logic

Spree allows partial validation of the +Checkout+ model (including associations) thanks to the concept of "validation groups".  This is a crucial addition to normal Rails validation because it allows Spree to validate only the pieces necessary for the current step (yet also validate the entire +Checkout+ when done.  The following is an example of a validation group defined in +checkout.rb+:

<ruby>
validation_group :register, :fields => ["email"]
</ruby>

This code tells Rails to only pay attention to validation errors related to the email field when processing the registration step.  By default, the +Checkout+ model will perform the standard Rails validation and report all errors.  You need to explicitly tell an instance of the checkout model which group to validate if you want only partial validation.  This is done in the +CheckoutsController+ as follows:

<ruby>
@checkout.enable_validation_group(@checkout.state.to_sym)
</ruby>

Its important to understand that the +Checkout+ model still works with regular Rails validation rules.  You can therefore add standard validation logic (typically through a site extension) for existing or additional fields.

h4. Adding or Removing Steps

Spree allows you to easily add or remove checkout steps.  We will outline the basic instructions for doing so here.  If you require more information, please read the detailed overview of "checkout architecture":#checkout-architecture.

h5. Changing the State Machine

Spree comes with a predefined series of checkout steps.  To make changes to this default flow you will need to alter the state machine for +Checkout+.  State machines are tricky to modify - the recommended approach is to simply define an entirely new state machine in your site extension.  

<ruby>
class SiteExtension < Spree::Extension  
  def activate
    # customize the checkout state machine
    Checkout.state_machines[:state] = StateMachine::Machine.new(Checkout, :initial => 'payment') do
      after_transition :to => 'complete', :do => :complete_order
      before_transition :to => 'complete', :do => :process_payment
      event :next do
        transition :to => 'complete', :from => 'payment'
      end
    end

    # bypass creation of address objects in the checkouts controller (prevent validation errors)
    CheckoutsController.class_eval do
      def object
        return @object if @object
        @object = parent_object.checkout
        unless params[:checkout] and params[:checkout][:coupon_code]
          @object.creditcard ||= Creditcard.new(:month => Date.today.month, :year => Date.today.year)
        end
        @object
      end
    end  
  end
end
</ruby>

NOTE. If you're planning on removing the address step you'll want to also override the +CheckoutsController+ (shown above) so that it does not create default +Address+ objects that will ultimately cause a failure during the final checkout validation.

You can also easily modify the state machine in your extension in order to add a new checkout step.  For instance, maybe you want to ask your user to select a calling plan if they are purchasing a cell phone.

h5. Registering new checkout steps

If you've added a new state to the Checkout model you will probably see the following error before reaching that step in the checkout process:

<ruby>
  NoMethodError in CheckoutsController#update
  undefined method `my_step' for CheckoutsController:Class
</ruby>

The solution is to register your step with CheckoutsController as follows. In future versions this shouldn't be necessary.

<ruby>
  CheckoutsController.class_eval do
    class_scoping_reader :my_step, Spree::Checkout::ActionOptions.new
  end
</ruby>


h5. The Checkout "Train"

The Spree code automatically creates a progress "train" based on the available checkout states.  If you add a new state you'll want to add a translation for that state in the relevant translation file located in the +config/locales+ directory of your extension.

<ruby>
---
en-US:   
  checkout_steps:
    # keys correspond to Checkout state names:
    new_step: New Step
</ruby>

INFO. The default use of the progress train is entirely optional.  It does not need to correspond to checkout states, nor does every state need to be represented.  Feel free to customize this behavior to meet your exact requirements.

h3. Coupons

Spree allows you to apply a coupon at any time during the checkout.  In order to process a coupon code during checkout you simply need to post a value for the +coupon_code+ attribute.  Spree does this by default in its checkout forms.

<html>
<input name="checkout[coupon_code]"/>  
</html>

INFO. If you need information on how to configure coupons please the detailed section on "coupons and discounts":coupons_and_discounts.html.

h3. Google Checkout and Paypal Express

It is possible to configure Spree to work with third party payment services such as Google Checkout and Paypal Express.  In this case you would simply configure your site theme to add the relevant buttons to your cart page (see the +README+ instructions for each of these extensions for more details.)  If you want to disable normal checkout you could also override the hook for the checkout button.

[TODO - detailed instructions on overriding the hook]

INFO. Spree does not automatically support Google Checkout or Paypal Express.  You will need to install the relevant third party extension if you wish to use these services.

h3. Data Security Issues

We end with a summary of how Spree protects sensitive data. Modifications in
your projects should aim to meet the same standards. You should also be aware
of relevant card processing recommendations or requirements, e.g. 
"PCI":https://www.pcisecuritystandards.org/.

* The checkout steps are processed via SSL, so sensitive data is never 
  transmitted in clear text.
* By default, sensitive credit card details are NOT stored in the database.
  Spree uses Rails hooks to blank out such sensitive data before containing
  records are saved. (However: this can be changed with the preference
  settings +Spree::Config[:store_cc]+ and +Spree::Config[:store_cvv]+ - 
  but this is not recommended).
* Most gateways use Active Merchant, and this itself uses appropriate
  techniques for secure transmission, e.g. submitting authorization
  requests only via SSL. 
