{"version":3,"sources":["../../src/actions/auth.ts","../../src/config.ts","../../src/cookies.ts","../../src/auth-helpers.ts"],"sourcesContent":["'use server';\n\nimport { revalidateTag } from 'next/cache';\nimport type { StoreUser } from '@spree/sdk';\nimport { getClient } from '../config';\nimport { setAccessToken, clearAccessToken, getAccessToken, getCartToken } from '../cookies';\nimport { withAuthRefresh } from '../auth-helpers';\n\n/**\n * Login with email and password.\n * Automatically associates any guest cart with the authenticated user.\n */\nexport async function login(\n  email: string,\n  password: string\n): Promise<{ success: boolean; user?: { id: string; email: string; first_name?: string | null; last_name?: string | null }; error?: string }> {\n  try {\n    const result = await getClient().auth.login({ email, password });\n    await setAccessToken(result.token);\n\n    // Associate guest cart if one exists\n    const cartToken = await getCartToken();\n    if (cartToken) {\n      try {\n        await getClient().cart.associate({\n          token: result.token,\n          orderToken: cartToken,\n        });\n      } catch {\n        // Cart association failure is non-fatal\n      }\n    }\n\n    revalidateTag('customer');\n    revalidateTag('cart');\n    return { success: true, user: result.user };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Invalid email or password',\n    };\n  }\n}\n\n/**\n * Register a new customer account.\n * Automatically associates any guest cart with the new account.\n */\nexport async function register(\n  email: string,\n  password: string,\n  passwordConfirmation: string\n): Promise<{ success: boolean; user?: { id: string; email: string; first_name?: string | null; last_name?: string | null }; error?: string }> {\n  try {\n    const result = await getClient().auth.register({\n      email,\n      password,\n      password_confirmation: passwordConfirmation,\n    });\n    await setAccessToken(result.token);\n\n    // Associate guest cart\n    const cartToken = await getCartToken();\n    if (cartToken) {\n      try {\n        await getClient().cart.associate({\n          token: result.token,\n          orderToken: cartToken,\n        });\n      } catch {\n        // Non-fatal\n      }\n    }\n\n    revalidateTag('customer');\n    revalidateTag('cart');\n    return { success: true, user: result.user };\n  } catch (error) {\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Registration failed',\n    };\n  }\n}\n\n/**\n * Logout the current user.\n */\nexport async function logout(): Promise<void> {\n  await clearAccessToken();\n  revalidateTag('customer');\n  revalidateTag('cart');\n  revalidateTag('addresses');\n  revalidateTag('credit-cards');\n}\n\n/**\n * Get the currently authenticated customer. Returns null if not logged in.\n */\nexport async function getCustomer(): Promise<StoreUser | null> {\n  const token = await getAccessToken();\n  if (!token) return null;\n\n  try {\n    return await withAuthRefresh(async (options) => {\n      return getClient().customer.get(options);\n    });\n  } catch {\n    await clearAccessToken();\n    return null;\n  }\n}\n\n/**\n * Update the current customer's profile.\n */\nexport async function updateCustomer(\n  data: { first_name?: string; last_name?: string; email?: string }\n): Promise<StoreUser> {\n  const result = await withAuthRefresh(async (options) => {\n    return getClient().customer.update(data, options);\n  });\n  revalidateTag('customer');\n  return result;\n}\n","import { createSpreeClient, type SpreeClient } from '@spree/sdk';\nimport type { SpreeNextConfig } from './types';\n\nlet _client: SpreeClient | null = null;\nlet _config: SpreeNextConfig | null = null;\n\n/**\n * Initialize the Spree Next.js integration.\n * Call this once in your app (e.g., in `lib/storefront.ts`).\n * If not called, the client will auto-initialize from SPREE_API_URL and SPREE_API_KEY env vars.\n */\nexport function initSpreeNext(config: SpreeNextConfig): void {\n  _config = config;\n  _client = createSpreeClient({\n    baseUrl: config.baseUrl,\n    apiKey: config.apiKey,\n  });\n}\n\n/**\n * Get the SpreeClient instance. Auto-initializes from env vars if needed.\n * @internal\n */\nexport function getClient(): SpreeClient {\n  if (!_client) {\n    const baseUrl = process.env.SPREE_API_URL;\n    const apiKey = process.env.SPREE_API_KEY;\n    if (baseUrl && apiKey) {\n      initSpreeNext({ baseUrl, apiKey });\n    } else {\n      throw new Error(\n        '@spree/next is not configured. Either call initSpreeNext() or set SPREE_API_URL and SPREE_API_KEY environment variables.'\n      );\n    }\n  }\n  return _client!;\n}\n\n/**\n * Get the current config. Auto-initializes from env vars if needed.\n * @internal\n */\nexport function getConfig(): SpreeNextConfig {\n  if (!_config) {\n    getClient(); // triggers auto-init\n  }\n  return _config!;\n}\n\n/**\n * Reset the client (useful for testing).\n * @internal\n */\nexport function resetClient(): void {\n  _client = null;\n  _config = null;\n}\n","import { cookies } from 'next/headers';\nimport { getConfig } from './config';\n\nconst DEFAULT_CART_COOKIE = '_spree_cart_token';\nconst DEFAULT_ACCESS_TOKEN_COOKIE = '_spree_jwt';\nconst CART_TOKEN_MAX_AGE = 60 * 60 * 24 * 30; // 30 days\nconst ACCESS_TOKEN_MAX_AGE = 60 * 60 * 24 * 7; // 7 days\n\nfunction getCartCookieName(): string {\n  try {\n    return getConfig().cartCookieName ?? DEFAULT_CART_COOKIE;\n  } catch {\n    return DEFAULT_CART_COOKIE;\n  }\n}\n\nfunction getAccessTokenCookieName(): string {\n  try {\n    return getConfig().accessTokenCookieName ?? DEFAULT_ACCESS_TOKEN_COOKIE;\n  } catch {\n    return DEFAULT_ACCESS_TOKEN_COOKIE;\n  }\n}\n\n// --- Cart Token ---\n\nexport async function getCartToken(): Promise<string | undefined> {\n  const cookieStore = await cookies();\n  return cookieStore.get(getCartCookieName())?.value;\n}\n\nexport async function setCartToken(token: string): Promise<void> {\n  const cookieStore = await cookies();\n  cookieStore.set(getCartCookieName(), token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax',\n    path: '/',\n    maxAge: CART_TOKEN_MAX_AGE,\n  });\n}\n\nexport async function clearCartToken(): Promise<void> {\n  const cookieStore = await cookies();\n  cookieStore.set(getCartCookieName(), '', {\n    maxAge: -1,\n    path: '/',\n  });\n}\n\n// --- Access Token (JWT) ---\n\nexport async function getAccessToken(): Promise<string | undefined> {\n  const cookieStore = await cookies();\n  return cookieStore.get(getAccessTokenCookieName())?.value;\n}\n\nexport async function setAccessToken(token: string): Promise<void> {\n  const cookieStore = await cookies();\n  cookieStore.set(getAccessTokenCookieName(), token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax',\n    path: '/',\n    maxAge: ACCESS_TOKEN_MAX_AGE,\n  });\n}\n\nexport async function clearAccessToken(): Promise<void> {\n  const cookieStore = await cookies();\n  cookieStore.set(getAccessTokenCookieName(), '', {\n    maxAge: -1,\n    path: '/',\n  });\n}\n","import { SpreeError } from '@spree/sdk';\nimport type { RequestOptions } from '@spree/sdk';\nimport { getClient } from './config';\nimport { getAccessToken, setAccessToken, clearAccessToken } from './cookies';\n\n/**\n * Get auth request options from the current JWT token.\n * Proactively refreshes the token if it expires within 1 hour.\n */\nexport async function getAuthOptions(): Promise<RequestOptions> {\n  const token = await getAccessToken();\n  if (!token) {\n    return {};\n  }\n\n  // Check if token is close to expiry by decoding JWT payload\n  try {\n    const payload = JSON.parse(atob(token.split('.')[1]));\n    const exp = payload.exp;\n    const now = Math.floor(Date.now() / 1000);\n\n    // Refresh if token expires in less than 1 hour\n    if (exp && exp - now < 3600) {\n      try {\n        const refreshed = await getClient().auth.refresh({ token });\n        await setAccessToken(refreshed.token);\n        return { token: refreshed.token };\n      } catch {\n        // Refresh failed — use existing token, it might still work\n      }\n    }\n  } catch {\n    // Can't decode JWT — use it as-is, the server will reject if invalid\n  }\n\n  return { token };\n}\n\n/**\n * Execute an authenticated request with automatic token refresh on 401.\n * @param fn - Function that takes RequestOptions and returns a promise\n * @returns The result of the function\n * @throws SpreeError if auth fails after refresh attempt\n */\nexport async function withAuthRefresh<T>(\n  fn: (options: RequestOptions) => Promise<T>\n): Promise<T> {\n  const options = await getAuthOptions();\n\n  if (!options.token) {\n    throw new Error('Not authenticated');\n  }\n\n  try {\n    return await fn(options);\n  } catch (error: unknown) {\n    // If 401, try refreshing the token once\n    if (error instanceof SpreeError && error.status === 401) {\n      try {\n        const refreshed = await getClient().auth.refresh({ token: options.token });\n        await setAccessToken(refreshed.token);\n        return await fn({ token: refreshed.token });\n      } catch {\n        // Refresh failed — clear token and rethrow\n        await clearAccessToken();\n        throw error;\n      }\n    }\n    throw error;\n  }\n}\n"],"mappings":";;;AAEA,SAAS,qBAAqB;;;ACF9B,SAAS,yBAA2C;AAGpD,IAAI,UAA8B;AAClC,IAAI,UAAkC;AAO/B,SAAS,cAAc,QAA+B;AAC3D,YAAU;AACV,YAAU,kBAAkB;AAAA,IAC1B,SAAS,OAAO;AAAA,IAChB,QAAQ,OAAO;AAAA,EACjB,CAAC;AACH;AAMO,SAAS,YAAyB;AACvC,MAAI,CAAC,SAAS;AACZ,UAAM,UAAU,QAAQ,IAAI;AAC5B,UAAM,SAAS,QAAQ,IAAI;AAC3B,QAAI,WAAW,QAAQ;AACrB,oBAAc,EAAE,SAAS,OAAO,CAAC;AAAA,IACnC,OAAO;AACL,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAMO,SAAS,YAA6B;AAC3C,MAAI,CAAC,SAAS;AACZ,cAAU;AAAA,EACZ;AACA,SAAO;AACT;;;AC/CA,SAAS,eAAe;AAGxB,IAAM,sBAAsB;AAC5B,IAAM,8BAA8B;AACpC,IAAM,qBAAqB,KAAK,KAAK,KAAK;AAC1C,IAAM,uBAAuB,KAAK,KAAK,KAAK;AAE5C,SAAS,oBAA4B;AACnC,MAAI;AACF,WAAO,UAAU,EAAE,kBAAkB;AAAA,EACvC,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEA,SAAS,2BAAmC;AAC1C,MAAI;AACF,WAAO,UAAU,EAAE,yBAAyB;AAAA,EAC9C,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAIA,eAAsB,eAA4C;AAChE,QAAM,cAAc,MAAM,QAAQ;AAClC,SAAO,YAAY,IAAI,kBAAkB,CAAC,GAAG;AAC/C;AAuBA,eAAsB,iBAA8C;AAClE,QAAM,cAAc,MAAM,QAAQ;AAClC,SAAO,YAAY,IAAI,yBAAyB,CAAC,GAAG;AACtD;AAEA,eAAsB,eAAe,OAA8B;AACjE,QAAM,cAAc,MAAM,QAAQ;AAClC,cAAY,IAAI,yBAAyB,GAAG,OAAO;AAAA,IACjD,UAAU;AAAA,IACV,QAAQ,QAAQ,IAAI,aAAa;AAAA,IACjC,UAAU;AAAA,IACV,MAAM;AAAA,IACN,QAAQ;AAAA,EACV,CAAC;AACH;AAEA,eAAsB,mBAAkC;AACtD,QAAM,cAAc,MAAM,QAAQ;AAClC,cAAY,IAAI,yBAAyB,GAAG,IAAI;AAAA,IAC9C,QAAQ;AAAA,IACR,MAAM;AAAA,EACR,CAAC;AACH;;;AC1EA,SAAS,kBAAkB;AAS3B,eAAsB,iBAA0C;AAC9D,QAAM,QAAQ,MAAM,eAAe;AACnC,MAAI,CAAC,OAAO;AACV,WAAO,CAAC;AAAA,EACV;AAGA,MAAI;AACF,UAAM,UAAU,KAAK,MAAM,KAAK,MAAM,MAAM,GAAG,EAAE,CAAC,CAAC,CAAC;AACpD,UAAM,MAAM,QAAQ;AACpB,UAAM,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AAGxC,QAAI,OAAO,MAAM,MAAM,MAAM;AAC3B,UAAI;AACF,cAAM,YAAY,MAAM,UAAU,EAAE,KAAK,QAAQ,EAAE,MAAM,CAAC;AAC1D,cAAM,eAAe,UAAU,KAAK;AACpC,eAAO,EAAE,OAAO,UAAU,MAAM;AAAA,MAClC,QAAQ;AAAA,MAER;AAAA,IACF;AAAA,EACF,QAAQ;AAAA,EAER;AAEA,SAAO,EAAE,MAAM;AACjB;AAQA,eAAsB,gBACpB,IACY;AACZ,QAAM,UAAU,MAAM,eAAe;AAErC,MAAI,CAAC,QAAQ,OAAO;AAClB,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AAEA,MAAI;AACF,WAAO,MAAM,GAAG,OAAO;AAAA,EACzB,SAAS,OAAgB;AAEvB,QAAI,iBAAiB,cAAc,MAAM,WAAW,KAAK;AACvD,UAAI;AACF,cAAM,YAAY,MAAM,UAAU,EAAE,KAAK,QAAQ,EAAE,OAAO,QAAQ,MAAM,CAAC;AACzE,cAAM,eAAe,UAAU,KAAK;AACpC,eAAO,MAAM,GAAG,EAAE,OAAO,UAAU,MAAM,CAAC;AAAA,MAC5C,QAAQ;AAEN,cAAM,iBAAiB;AACvB,cAAM;AAAA,MACR;AAAA,IACF;AACA,UAAM;AAAA,EACR;AACF;;;AH1DA,eAAsB,MACpB,OACA,UAC4I;AAC5I,MAAI;AACF,UAAM,SAAS,MAAM,UAAU,EAAE,KAAK,MAAM,EAAE,OAAO,SAAS,CAAC;AAC/D,UAAM,eAAe,OAAO,KAAK;AAGjC,UAAM,YAAY,MAAM,aAAa;AACrC,QAAI,WAAW;AACb,UAAI;AACF,cAAM,UAAU,EAAE,KAAK,UAAU;AAAA,UAC/B,OAAO,OAAO;AAAA,UACd,YAAY;AAAA,QACd,CAAC;AAAA,MACH,QAAQ;AAAA,MAER;AAAA,IACF;AAEA,kBAAc,UAAU;AACxB,kBAAc,MAAM;AACpB,WAAO,EAAE,SAAS,MAAM,MAAM,OAAO,KAAK;AAAA,EAC5C,SAAS,OAAO;AACd,WAAO;AAAA,MACL,SAAS;AAAA,MACT,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,IAClD;AAAA,EACF;AACF;AAMA,eAAsB,SACpB,OACA,UACA,sBAC4I;AAC5I,MAAI;AACF,UAAM,SAAS,MAAM,UAAU,EAAE,KAAK,SAAS;AAAA,MAC7C;AAAA,MACA;AAAA,MACA,uBAAuB;AAAA,IACzB,CAAC;AACD,UAAM,eAAe,OAAO,KAAK;AAGjC,UAAM,YAAY,MAAM,aAAa;AACrC,QAAI,WAAW;AACb,UAAI;AACF,cAAM,UAAU,EAAE,KAAK,UAAU;AAAA,UAC/B,OAAO,OAAO;AAAA,UACd,YAAY;AAAA,QACd,CAAC;AAAA,MACH,QAAQ;AAAA,MAER;AAAA,IACF;AAEA,kBAAc,UAAU;AACxB,kBAAc,MAAM;AACpB,WAAO,EAAE,SAAS,MAAM,MAAM,OAAO,KAAK;AAAA,EAC5C,SAAS,OAAO;AACd,WAAO;AAAA,MACL,SAAS;AAAA,MACT,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,IAClD;AAAA,EACF;AACF;AAKA,eAAsB,SAAwB;AAC5C,QAAM,iBAAiB;AACvB,gBAAc,UAAU;AACxB,gBAAc,MAAM;AACpB,gBAAc,WAAW;AACzB,gBAAc,cAAc;AAC9B;AAKA,eAAsB,cAAyC;AAC7D,QAAM,QAAQ,MAAM,eAAe;AACnC,MAAI,CAAC,MAAO,QAAO;AAEnB,MAAI;AACF,WAAO,MAAM,gBAAgB,OAAO,YAAY;AAC9C,aAAO,UAAU,EAAE,SAAS,IAAI,OAAO;AAAA,IACzC,CAAC;AAAA,EACH,QAAQ;AACN,UAAM,iBAAiB;AACvB,WAAO;AAAA,EACT;AACF;AAKA,eAAsB,eACpB,MACoB;AACpB,QAAM,SAAS,MAAM,gBAAgB,OAAO,YAAY;AACtD,WAAO,UAAU,EAAE,SAAS,OAAO,MAAM,OAAO;AAAA,EAClD,CAAC;AACD,gBAAc,UAAU;AACxB,SAAO;AACT;","names":[]}